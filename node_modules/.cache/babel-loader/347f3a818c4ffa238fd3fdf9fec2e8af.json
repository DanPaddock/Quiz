{"ast":null,"code":"import React, { useEffect, useState, useContext } from 'react';\nimport create from 'zustand';\nimport produce from 'immer';\nimport PropTypes from 'prop-types';\nimport TagsInput from 'react-tagsinput';\nimport unquote from 'unquote';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar immer = function immer(config) {\n  return function (set, get) {\n    return config(function (fn) {\n      return set(produce(fn));\n    }, get);\n  };\n}; // TODO fix these types\n\n\nvar store = function store(set) {\n  return {\n    data: {},\n    isReady: {},\n    defaultValues: {},\n    setForm: function setForm(formData, formId) {\n      return set(function (state) {\n        state.data[formId] = _extends({}, formData);\n      });\n    },\n    setField: function setField(id, value, formId) {\n      return set(function (state) {\n        state.data[formId][id] = value;\n      });\n    },\n    setDefaults: function setDefaults(formData, formId) {\n      return set(function (state) {\n        state.defaultValues[formId] = _extends({}, formData);\n      });\n    },\n    register: function register(formData, formId) {\n      return set(function (state) {\n        state.data[formId] = _extends({}, formData);\n        state.defaultValues[formId] = _extends({}, formData);\n        state.isReady[formId] = true;\n      });\n    },\n    unregister: function unregister(formId) {\n      return set(function (state) {\n        state.isReady[formId] = false;\n      });\n    },\n    registerField: function registerField(fieldId, defaultValue, formId) {\n      return set(function (state) {\n        state.data[formId][fieldId] = defaultValue;\n      });\n    },\n    resetForm: function resetForm(formId) {\n      return set(function (state) {\n        state.data[formId] = state.defaultValues[formId];\n      });\n    }\n  };\n};\n\nvar useForm = /*#__PURE__*/create( /*#__PURE__*/immer(store));\nvar FormContext = /*#__PURE__*/React.createContext(null);\n\nvar CancelButton = function CancelButton(_ref) {\n  var cancelAction = _ref.cancelAction,\n      _ref$cancelText = _ref.cancelText,\n      cancelText = _ref$cancelText === void 0 ? 'Cancel' : _ref$cancelText,\n      formId = _ref.formId;\n\n  var _useForm = useForm(),\n      resetForm = _useForm.resetForm;\n\n  return React.createElement(\"button\", {\n    id: \"fresh-cancel\",\n    className: \"fresh-button fresh-cancel\",\n    onClick: function onClick() {\n      cancelAction(formId);\n      resetForm(formId);\n    },\n    type: \"reset\"\n  }, cancelText);\n};\n\nvar Tooltip = function Tooltip(_ref) {\n  var tooltip = _ref.tooltip,\n      tooltipBackground = _ref.tooltipBackground,\n      tooltipColor = _ref.tooltipColor,\n      tooltipIconColor = _ref.tooltipIconColor;\n  var tooltipStyle = {\n    '--fresh-tooltip-background': tooltipBackground,\n    '--fresh-tooltip-color': tooltipColor,\n    '--fresh-tooltip-icon-color': tooltipIconColor\n  };\n  return React.createElement(\"span\", {\n    className: \"fresh-tooltip\",\n    \"data-tooltip\": tooltip,\n    style: tooltipStyle\n  }, React.createElement(\"svg\", {\n    className: \"fresh-tooltip-icon\",\n    width: \"16\",\n    height: \"16\",\n    viewBox: \"0 0 16 16\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16ZM9.02539 5.91797H5.84668V7.79102H6.91309V11.127H5.84668V13H10.0098V11.127H9.02539V5.91797ZM6.89258 3.16309C6.83333 3.30892 6.80371 3.46615 6.80371 3.63477C6.80371 3.80339 6.83333 3.96289 6.89258 4.11328C6.95638 4.25911 7.04297 4.38672 7.15234 4.49609C7.26172 4.60547 7.38932 4.69206 7.53516 4.75586C7.68555 4.81966 7.84733 4.85156 8.02051 4.85156C8.18457 4.85156 8.33952 4.81966 8.48535 4.75586C8.63118 4.69206 8.75879 4.60547 8.86816 4.49609C8.97754 4.38672 9.06413 4.25911 9.12793 4.11328C9.19173 3.96289 9.22363 3.80339 9.22363 3.63477C9.22363 3.46615 9.19173 3.30892 9.12793 3.16309C9.06413 3.0127 8.97754 2.88281 8.86816 2.77344C8.75879 2.66406 8.63118 2.57747 8.48535 2.51367C8.33952 2.44987 8.18457 2.41797 8.02051 2.41797C7.84733 2.41797 7.68555 2.44987 7.53516 2.51367C7.38932 2.57747 7.26172 2.66406 7.15234 2.77344C7.04297 2.88281 6.95638 3.0127 6.89258 3.16309Z\",\n    fill: tooltipIconColor\n  })));\n};\n\nTooltip.propTypes = {\n  tooltip: PropTypes.string,\n  tooltipBackground: PropTypes.string,\n  tooltipColor: PropTypes.string,\n  tooltipIconColor: PropTypes.string\n};\nTooltip.defaultProps = {\n  tooltip: '',\n  tooltipBackground: '#eee',\n  tooltipColor: '#000',\n  tooltipIconColor: '#000'\n};\n\nvar Select = function Select(_ref) {\n  var options = _ref.options,\n      fieldId = _ref.fieldId,\n      formId = _ref.formId,\n      _ref$displayProperty = _ref.displayProperty,\n      displayProperty = _ref$displayProperty === void 0 ? '' : _ref$displayProperty,\n      _ref$valueProperty = _ref.valueProperty,\n      valueProperty = _ref$valueProperty === void 0 ? '' : _ref$valueProperty,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      registerField = _useForm.registerField,\n      defaultValues = _useForm.defaultValues;\n\n  useEffect(function () {\n    var _defaultValues$formId, _defaultValues$formId2, _defaultValues$formId3, _defaultValues$formId4;\n\n    var defaultValue = (defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId = defaultValues[formId]) === null || _defaultValues$formId === void 0 ? void 0 : _defaultValues$formId[fieldId]) ? (defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId2 = defaultValues[formId]) === null || _defaultValues$formId2 === void 0 ? void 0 : (_defaultValues$formId3 = _defaultValues$formId2[fieldId]) === null || _defaultValues$formId3 === void 0 ? void 0 : _defaultValues$formId3[valueProperty]) || (defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId4 = defaultValues[formId]) === null || _defaultValues$formId4 === void 0 ? void 0 : _defaultValues$formId4[fieldId]) : options[0];\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null;\n  return React.createElement(\"select\", {\n    id: \"fresh-\" + fieldId + \"-\" + formId,\n    className: \"fresh-input fresh-input-select \" + className,\n    onChange: function onChange(e) {\n      return setField(fieldId, e.target.value, formId);\n    },\n    value: data[formId][fieldId]\n  }, options.map(function (option, i) {\n    return React.createElement(\"option\", {\n      value: (option === null || option === void 0 ? void 0 : option[valueProperty]) || option,\n      key: \"fresh-\" + fieldId + \"-\" + formId + \"-\" + i,\n      className: \"fresh-option\"\n    }, (option === null || option === void 0 ? void 0 : option[displayProperty]) || option);\n  }));\n};\n\nvar Reference = function Reference(_ref) {\n  var _defaultValues$formId, _defaultValues$formId2;\n\n  var options = _ref.options,\n      fieldId = _ref.fieldId,\n      _ref$keyProperty = _ref.keyProperty,\n      keyProperty = _ref$keyProperty === void 0 ? 'id' : _ref$keyProperty,\n      displayProperty = _ref.displayProperty,\n      _ref$placeholder = _ref.placeholder,\n      placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      formId = _ref.formId;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      isReady = _useForm.isReady,\n      defaultValues = _useForm.defaultValues,\n      registerField = _useForm.registerField;\n\n  var _useState = useState((defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId = defaultValues[formId]) === null || _defaultValues$formId === void 0 ? void 0 : (_defaultValues$formId2 = _defaultValues$formId[fieldId]) === null || _defaultValues$formId2 === void 0 ? void 0 : _defaultValues$formId2[displayProperty]) || ''),\n      inputValue = _useState[0],\n      setInputValue = _useState[1];\n\n  var _useState2 = useState(false),\n      isFocused = _useState2[0],\n      setIsFocused = _useState2[1];\n\n  useEffect(function () {\n    var _defaultValues$formId3, _defaultValues$formId4;\n\n    var defaultValue = (_defaultValues$formId3 = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId4 = defaultValues[formId]) === null || _defaultValues$formId4 === void 0 ? void 0 : _defaultValues$formId4[fieldId]) !== null && _defaultValues$formId3 !== void 0 ? _defaultValues$formId3 : '';\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null; // If the form is not registered or there is not data object\n\n  if (!isReady) return null;\n  return React.createElement(React.Fragment, null, React.createElement(\"input\", {\n    id: \"fresh-\" + fieldId + \"-\" + formId,\n    onChange: function onChange(e) {\n      return setInputValue(e.target.value);\n    },\n    value: inputValue,\n    onFocus: function onFocus() {\n      return setIsFocused(true);\n    },\n    onBlur: function onBlur() {\n      return setIsFocused(false);\n    },\n    placeholder: placeholder,\n    type: \"text\",\n    className: \"fresh-input fresh-input-reference \" + className\n  }), isFocused && React.createElement(\"div\", {\n    className: \"fresh-focused\"\n  }, options.filter(function (option) {\n    return option[displayProperty].toLowerCase().includes(inputValue.toLowerCase());\n  }).map(function (option) {\n    return React.createElement(\"div\", {\n      key: option[keyProperty],\n      style: {\n        padding: '0.75em'\n      },\n      onMouseDown: function onMouseDown() {\n        setField(fieldId, option, formId);\n        setInputValue(option[displayProperty]);\n      }\n    }, option[displayProperty]);\n  })));\n};\n\nvar Password = function Password(_ref) {\n  var _data$formId$fieldId;\n\n  var placeholder = _ref.placeholder,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      required = _ref.required,\n      fieldId = _ref.fieldId,\n      _ref$strength = _ref.strength,\n      strength = _ref$strength === void 0 ? true : _ref$strength,\n      type = _ref.type,\n      formId = _ref.formId;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      defaultValues = _useForm.defaultValues,\n      registerField = _useForm.registerField; // If the form is not registered or there is not data object\n\n\n  useEffect(function () {\n    var _defaultValues$formId, _defaultValues$formId2;\n\n    var defaultValue = (_defaultValues$formId = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId2 = defaultValues[formId]) === null || _defaultValues$formId2 === void 0 ? void 0 : _defaultValues$formId2[fieldId]) !== null && _defaultValues$formId !== void 0 ? _defaultValues$formId : '';\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null;\n  var strengthValue = calculateScore((_data$formId$fieldId = data[formId][fieldId]) !== null && _data$formId$fieldId !== void 0 ? _data$formId$fieldId : '');\n  var strengthMeter = {\n    background: '#ccc',\n    width: 'calc(193px * 0.25)'\n  };\n\n  if (strengthValue >= 2 && strengthValue < 3) {\n    strengthMeter = {\n      width: 'calc(193px * 0.5)',\n      background: 'red'\n    };\n  } else if (strengthValue >= 3 && strengthValue < 4) {\n    strengthMeter = {\n      width: 'calc(193px * 0.75)',\n      background: 'red'\n    };\n  } else if (strengthValue >= 4) {\n    strengthMeter = {\n      width: 'calc(193px * 1)',\n      background: 'green'\n    };\n  }\n\n  return React.createElement(React.Fragment, null, React.createElement(\"input\", {\n    className: \"fresh-input fresh-input-password \" + className,\n    placeholder: placeholder,\n    type: type,\n    required: required,\n    id: \"fresh-\" + fieldId + \"-\" + formId,\n    value: data[formId][fieldId],\n    onChange: function onChange(e) {\n      return setField(fieldId, e.target.value, formId);\n    }\n  }), strength && React.createElement(\"div\", {\n    style: _extends({\n      height: '4px',\n      marginBottom: '1rem',\n      transition: '0.3s ease all'\n    }, strengthMeter)\n  }));\n};\n\nvar options = {\n  showText: true,\n  fieldPartialMatch: true,\n  minimumLength: 4\n};\n\nfunction calculateScore(password) {\n  var score = 0; // password < options.minimumLength\n\n  if (password.length < options.minimumLength) {\n    return -1;\n  } // password length\n\n\n  score += password.length * 4; // password has 3 numbers\n\n  if (password.match(/(.*[0-9].*[0-9].*[0-9])/)) {\n    score += 5;\n  } // password has at least 2 sybols\n\n\n  var symbols = '.*[!,@,#,$,%,^,&,*,?,_,~]';\n  symbols = new RegExp('(' + symbols + symbols + ')');\n\n  if (password.match(symbols)) {\n    score += 5;\n  } // password has Upper and Lower chars\n\n\n  if (password.match(/([a-z].*[A-Z])|([A-Z].*[a-z])/)) {\n    score += 10;\n  } // password has number and chars\n\n\n  if (password.match(/([a-zA-Z])/) && password.match(/([0-9])/)) {\n    score += 15;\n  } // password has number and symbol\n\n\n  if (password.match(/([!,@,#,$,%,^,&,*,?,_,~])/) && password.match(/([0-9])/)) {\n    score += 15;\n  } // password has char and symbol\n\n\n  if (password.match(/([!,@,#,$,%,^,&,*,?,_,~])/) && password.match(/([a-zA-Z])/)) {\n    score += 15;\n  } // password is just numbers or chars\n\n\n  if (password.match(/^\\w+$/) || password.match(/^\\d+$/)) {\n    score -= 10;\n  }\n\n  if (score > 100) {\n    score = 100;\n  }\n\n  if (score < 0) {\n    score = 0;\n  }\n\n  return score * 0.04;\n}\n\nvar Tags = function Tags(_ref) {\n  var fieldId = _ref.fieldId,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      formId = _ref.formId;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      defaultValues = _useForm.defaultValues,\n      registerField = _useForm.registerField;\n\n  useEffect(function () {\n    var _defaultValues$formId, _defaultValues$formId2;\n\n    var defaultValue = (_defaultValues$formId = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId2 = defaultValues[formId]) === null || _defaultValues$formId2 === void 0 ? void 0 : _defaultValues$formId2[fieldId]) !== null && _defaultValues$formId !== void 0 ? _defaultValues$formId : [];\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null;\n  return React.createElement(TagsInput, {\n    value: data[formId][fieldId] || [],\n    onChange: function onChange(value) {\n      return setField(fieldId, value, formId);\n    },\n    className: \"fresh-input-tags \" + className,\n    id: \"fresh-\" + fieldId + \"-\" + formId,\n    style: {\n      marginTop: '1rem'\n    }\n  });\n};\n\nvar TextArea = function TextArea(_ref) {\n  var className = _ref.className,\n      fieldId = _ref.fieldId,\n      formId = _ref.formId,\n      placeholder = _ref.placeholder;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      registerField = _useForm.registerField,\n      defaultValues = _useForm.defaultValues;\n\n  useEffect(function () {\n    var _defaultValues$formId, _defaultValues$formId2;\n\n    var defaultValue = (_defaultValues$formId = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId2 = defaultValues[formId]) === null || _defaultValues$formId2 === void 0 ? void 0 : _defaultValues$formId2[fieldId]) !== null && _defaultValues$formId !== void 0 ? _defaultValues$formId : '';\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null;\n  return React.createElement(\"textarea\", {\n    id: \"fresh-\" + fieldId + \"-\" + formId,\n    placeholder: placeholder,\n    value: data[formId][fieldId],\n    className: \"fresh-input fresh-input-textarea \" + className,\n    onChange: function onChange(e) {\n      return setField(fieldId, e.target.value, formId);\n    }\n  });\n};\n\nvar NumberField = function NumberField(_ref) {\n  var fieldId = _ref.fieldId,\n      placeholder = _ref.placeholder,\n      required = _ref.required,\n      formId = _ref.formId,\n      className = _ref.className;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      defaultValues = _useForm.defaultValues,\n      registerField = _useForm.registerField;\n\n  useEffect(function () {\n    var _defaultValues$formId, _defaultValues$formId2;\n\n    var defaultValue = (_defaultValues$formId = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId2 = defaultValues[formId]) === null || _defaultValues$formId2 === void 0 ? void 0 : _defaultValues$formId2[fieldId]) !== null && _defaultValues$formId !== void 0 ? _defaultValues$formId : '';\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null;\n  return React.createElement(\"input\", {\n    required: required,\n    className: \"fresh-input fresh-input-number \" + className,\n    placeholder: placeholder,\n    id: \"fresh-\" + fieldId + \"-\" + formId,\n    type: \"number\",\n    value: data[formId][fieldId],\n    onChange: function onChange(e) {\n      var value = e.target.value ? parseInt(e.target.value) : null;\n      setField(fieldId, value, formId);\n    }\n  });\n};\n/** TODO: Drop for React 16? */\n\n\nvar ATTRIBUTE_TO_JSX_PROP_MAP = {\n  accesskey: 'accessKey',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  autocomplete: 'autoComplete',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  charset: 'charSet',\n  \"class\": 'className',\n  classid: 'classId',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  crossorigin: 'crossOrigin',\n  enctype: 'encType',\n  \"for\": 'htmlFor',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formmethod: 'formMethod',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  hreflang: 'hrefLang',\n  inputmode: 'inputMode',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  marginheight: 'marginHeight',\n  marginwidth: 'marginWidth',\n  maxlength: 'maxLength',\n  mediagroup: 'mediaGroup',\n  minlength: 'minLength',\n  novalidate: 'noValidate',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  spellcheck: 'spellCheck',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  tabindex: 'tabIndex',\n  usemap: 'useMap'\n};\nvar namedCodesToUnicode = {\n  amp: \"&\",\n  apos: \"'\",\n  gt: \">\",\n  lt: \"<\",\n  nbsp: \"\\xA0\",\n  quot: \"\\u201C\"\n};\nvar DO_NOT_PROCESS_HTML_ELEMENTS = ['style', 'script'];\n/**\r\n * the attribute extractor regex looks for a valid attribute name,\r\n * followed by an equal sign (whitespace around the equal sign is allowed), followed\r\n * by one of the following:\r\n *\r\n * 1. a single quote-bounded string, e.g. 'foo'\r\n * 2. a double quote-bounded string, e.g. \"bar\"\r\n * 3. an interpolation, e.g. {something}\r\n *\r\n * JSX can be be interpolated into itself and is passed through the compiler using\r\n * the same options and setup as the current run.\r\n *\r\n * <Something children={<SomeOtherThing />} />\r\n *                      ==================\r\n *                              ↳ children: [<SomeOtherThing />]\r\n *\r\n * Otherwise, interpolations are handled as strings or simple booleans\r\n * unless HTML syntax is detected.\r\n *\r\n * <Something color={green} disabled={true} />\r\n *                   =====            ====\r\n *                     ↓                ↳ disabled: true\r\n *                     ↳ color: \"green\"\r\n *\r\n * Numbers are not parsed at this time due to complexities around int, float,\r\n * and the upcoming bigint functionality that would make handling it unwieldy.\r\n * Parse the string in your component as desired.\r\n *\r\n * <Something someBigNumber={123456789123456789} />\r\n *                           ==================\r\n *                                   ↳ someBigNumber: \"123456789123456789\"\r\n */\n\nvar ATTR_EXTRACTOR_R = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi;\n/** TODO: Write explainers for each of these */\n\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\nvar BLOCK_END_R = /\\n{2,}$/;\nvar BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/;\nvar BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm;\nvar BREAK_LINE_R = /^ {2,}\\n/;\nvar BREAK_THEMATIC_R = /^(?:( *[-*_]) *){3,}(?:\\n *)+\\n/;\nvar CODE_BLOCK_FENCED_R = /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n?/;\nvar CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/;\nvar CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/;\nvar CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/;\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar FOOTNOTE_R = /^\\[\\^([^\\]]+)](:.*)\\n/;\nvar FOOTNOTE_REFERENCE_R = /^\\[\\^([^\\]]+)]/;\nvar FORMFEED_R = /\\f/g;\nvar GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/;\nvar HEADING_R = /^ *(#{1,6}) *([^\\n]+)\\n{0,2}/;\nvar HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/;\n/**\r\n * Explanation:\r\n *\r\n * 1. Look for a starting tag, preceeded by any amount of spaces\r\n *    ^ *<\r\n *\r\n * 2. Capture the tag name (capture 1)\r\n *    ([^ >/]+)\r\n *\r\n * 3. Ignore a space after the starting tag and capture the attribute portion of the tag (capture 2)\r\n *     ?([^>]*)\\/{0}>\r\n *\r\n * 4. Ensure a matching closing tag is present in the rest of the input string\r\n *    (?=[\\s\\S]*<\\/\\1>)\r\n *\r\n * 5. Capture everything until the matching closing tag -- this might include additional pairs\r\n *    of the same tag type found in step 2 (capture 3)\r\n *    ((?:[\\s\\S]*?(?:<\\1[^>]*>[\\s\\S]*?<\\/\\1>)*[\\s\\S]*?)*?)<\\/\\1>\r\n *\r\n * 6. Capture excess newlines afterward\r\n *    \\n*\r\n */\n\nvar HTML_BLOCK_ELEMENT_R = /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i;\nvar HTML_CHAR_CODE_R = /&([a-z]+);/g;\nvar HTML_COMMENT_R = /^<!--.*?-->/;\n/**\r\n * borrowed from React 15(https://github.com/facebook/react/blob/894d20744cba99383ffd847dbd5b6e0800355a5c/src/renderers/dom/shared/HTMLDOMPropertyConfig.js)\r\n */\n\nvar HTML_CUSTOM_ATTR_R = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/;\nvar HTML_SELF_CLOSING_ELEMENT_R = /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i;\nvar INTERPOLATION_R = /^\\{.*\\}$/;\nvar LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/;\nvar LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/;\nvar LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/;\nvar LIST_ITEM_END_R = / *\\n+$/;\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\nvar CAPTURE_LETTER_AFTER_HYPHEN = /-([a-z])?/gi;\nvar NP_TABLE_R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/;\nvar PARAGRAPH_R = /^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/;\nvar REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/;\nvar REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/;\nvar REFERENCE_LINK_R = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/;\nvar SQUARE_BRACKETS_R = /(\\[|\\])/g;\nvar SHOULD_RENDER_AS_BLOCK_R = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/;\nvar TAB_R = /\\t/g;\nvar TABLE_SEPARATOR_R = /^ *\\| */;\nvar TABLE_TRIM_PIPES = /(^ *\\||\\| *$)/g;\nvar TABLE_CELL_END_TRIM = / *$/;\nvar TABLE_CENTER_ALIGN = /^ *:-+: *$/;\nvar TABLE_LEFT_ALIGN = /^ *:-+ *$/;\nvar TABLE_RIGHT_ALIGN = /^ *-+: *$/;\nvar TEXT_BOLD_R = /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/;\nvar TEXT_EMPHASIZED_R = /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1)/;\nvar TEXT_STRIKETHROUGHED_R = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/;\nvar TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/;\nvar TEXT_PLAIN_R = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i;\nvar TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R = /(^\\n+|\\n+$|\\s+$)/g;\nvar HTML_LEFT_TRIM_AMOUNT_R = /^([ \\t]*)/;\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Z\\s])/gi; // recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\n\nvar LIST_BULLET = '(?:[*+-]|\\\\d+\\\\.)'; // recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\n\nvar LIST_ITEM_PREFIX = '( *)(' + LIST_BULLET + ') +';\nvar LIST_ITEM_PREFIX_R = /*#__PURE__*/new RegExp('^' + LIST_ITEM_PREFIX); // recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\n\nvar LIST_ITEM_R = /*#__PURE__*/new RegExp(LIST_ITEM_PREFIX + '[^\\\\n]*(?:\\\\n' + '(?!\\\\1' + LIST_BULLET + ' )[^\\\\n]*)*(\\\\n|$)', 'gm'); // check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\n\nvar LIST_R = /*#__PURE__*/new RegExp('^( *)(' + LIST_BULLET + ') ' + '[\\\\s\\\\S]+?(?:\\\\n{2,}(?! )' + '(?!\\\\1' + LIST_BULLET + ' (?!' + LIST_BULLET + ' ))\\\\n*' + // the \\\\s*$ here is so that we can parse the inside of nested\n// lists, where our content might end before we receive two `\\n`s\n'|\\\\s*\\\\n*$)');\nvar LINK_INSIDE = '(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*';\nvar LINK_HREF_AND_TITLE = '\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+[\\'\"]([\\\\s\\\\S]*?)[\\'\"])?\\\\s*';\nvar LINK_R = /*#__PURE__*/new RegExp('^\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)');\nvar IMAGE_R = /*#__PURE__*/new RegExp('^!\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)');\nvar BLOCK_SYNTAXES = [BLOCKQUOTE_R, CODE_BLOCK_R, CODE_BLOCK_FENCED_R, HEADING_R, HEADING_SETEXT_R, HTML_BLOCK_ELEMENT_R, HTML_COMMENT_R, HTML_SELF_CLOSING_ELEMENT_R, LIST_ITEM_R, LIST_R, NP_TABLE_R, PARAGRAPH_R];\n\nfunction containsBlockSyntax(input) {\n  return BLOCK_SYNTAXES.some(function (r) {\n    return r.test(input);\n  });\n} // based on https://stackoverflow.com/a/18123682/1141611\n// not complete, but probably good enough\n\n\nfunction slugify(str) {\n  return str.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, 'a').replace(/[çÇ]/g, 'c').replace(/[ðÐ]/g, 'd').replace(/[ÈÉÊËéèêë]/g, 'e').replace(/[ÏïÎîÍíÌì]/g, 'i').replace(/[Ññ]/g, 'n').replace(/[øØœŒÕõÔôÓóÒò]/g, 'o').replace(/[ÜüÛûÚúÙù]/g, 'u').replace(/[ŸÿÝý]/g, 'y').replace(/[^a-z0-9- ]/gi, '').replace(/ /gi, '-').toLowerCase();\n}\n\nfunction parseTableAlignCapture(alignCapture) {\n  if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n    return 'right';\n  } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n    return 'center';\n  } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n    return 'left';\n  }\n\n  return null;\n}\n\nfunction parseTableRow(source, parse, state) {\n  var prevInTable = state.inTable;\n  state.inTable = true;\n  var tableRow = parse(source.trim(), state);\n  state.inTable = prevInTable;\n  var cells = [[]];\n  tableRow.forEach(function (node, i) {\n    if (node.type === 'tableSeparator') {\n      // Filter out empty table separators at the start/end:\n      if (i !== 0 && i !== tableRow.length - 1) {\n        // Split the current row:\n        cells.push([]);\n      }\n    } else {\n      if (node.type === 'text' && (tableRow[i + 1] == null || tableRow[i + 1].type === 'tableSeparator')) {\n        node.content = node.content.replace(TABLE_CELL_END_TRIM, '');\n      }\n\n      cells[cells.length - 1].push(node);\n    }\n  });\n  return cells;\n}\n\nfunction parseTableAlign(source\n/*, parse, state*/\n) {\n  var alignText = source.replace(TABLE_TRIM_PIPES, '').split('|');\n  return alignText.map(parseTableAlignCapture);\n}\n\nfunction parseTableCells(source, parse, state) {\n  var rowsText = source.trim().split('\\n');\n  return rowsText.map(function (rowText) {\n    return parseTableRow(rowText, parse, state);\n  });\n}\n\nfunction parseTable(capture, parse, state) {\n  state.inline = true;\n  var header = parseTableRow(capture[1], parse, state);\n  var align = parseTableAlign(capture[2]);\n  var cells = parseTableCells(capture[3], parse, state);\n  state.inline = false;\n  return {\n    align: align,\n    cells: cells,\n    header: header,\n    type: 'table'\n  };\n}\n\nfunction getTableStyle(node, colIndex) {\n  return node.align[colIndex] == null ? {} : {\n    textAlign: node.align[colIndex]\n  };\n}\n/** TODO: remove for react 16 */\n\n\nfunction normalizeAttributeKey(key) {\n  var hyphenIndex = key.indexOf('-');\n\n  if (hyphenIndex !== -1 && key.match(HTML_CUSTOM_ATTR_R) === null) {\n    key = key.replace(CAPTURE_LETTER_AFTER_HYPHEN, function (_, letter) {\n      return letter.toUpperCase();\n    });\n  }\n\n  return key;\n}\n\nfunction attributeValueToJSXPropValue(key, value) {\n  if (key === 'style') {\n    return value.split(/;\\s?/).reduce(function (styles, kvPair) {\n      var key = kvPair.slice(0, kvPair.indexOf(':')); // snake-case to camelCase\n      // also handles PascalCasing vendor prefixes\n\n      var camelCasedKey = key.replace(/(-[a-z])/g, function (substr) {\n        return substr[1].toUpperCase();\n      }); // key.length + 1 to skip over the colon\n\n      styles[camelCasedKey] = kvPair.slice(key.length + 1).trim();\n      return styles;\n    }, {});\n  } else if (key === 'href') {\n    return sanitizeUrl(value);\n  } else if (value.match(INTERPOLATION_R)) {\n    // return as a string and let the consumer decide what to do with it\n    value = value.slice(1, value.length - 1);\n  }\n\n  if (value === 'true') {\n    return true;\n  } else if (value === 'false') {\n    return false;\n  }\n\n  return value;\n}\n\nfunction normalizeWhitespace(source) {\n  return source.replace(CR_NEWLINE_R, '\\n').replace(FORMFEED_R, '').replace(TAB_R, '    ');\n}\n/**\r\n * Creates a parser for a given set of rules, with the precedence\r\n * specified as a list of rules.\r\n *\r\n * @rules: an object containing\r\n * rule type -> {match, order, parse} objects\r\n * (lower order is higher precedence)\r\n * (Note: `order` is added to defaultRules after creation so that\r\n *  the `order` of defaultRules in the source matches the `order`\r\n *  of defaultRules in terms of `order` fields.)\r\n *\r\n * @returns The resulting parse function, with the following parameters:\r\n *   @source: the input source string to be parsed\r\n *   @state: an optional object to be threaded through parse\r\n *     calls. Allows clients to add stateful operations to\r\n *     parsing, such as keeping track of how many levels deep\r\n *     some nesting is. For an example use-case, see passage-ref\r\n *     parsing in src/widgets/passage/passage-markdown.jsx\r\n */\n\n\nfunction parserFor(rules) {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  var ruleList = Object.keys(rules);\n  /* istanbul ignore next */\n\n  if (process.env.NODE_ENV !== 'production') {\n    ruleList.forEach(function (type) {\n      var order = rules[type].order;\n\n      if (process.env.NODE_ENV !== 'production' && (typeof order !== 'number' || !isFinite(order))) {\n        console.warn('markdown-to-jsx: Invalid order for rule `' + type + '`: ' + order);\n      }\n    });\n  }\n\n  ruleList.sort(function (typeA, typeB) {\n    var orderA = rules[typeA].order;\n    var orderB = rules[typeB].order; // First sort based on increasing order\n\n    if (orderA !== orderB) {\n      return orderA - orderB; // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1;\n    }\n\n    return 1;\n  });\n\n  function nestedParse(source, state) {\n    var result = []; // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information).\n\n    var prevCapture = '';\n\n    while (source) {\n      var i = 0;\n\n      while (i < ruleList.length) {\n        var ruleType = ruleList[i];\n        var rule = rules[ruleType];\n        var capture = rule.match(source, state, prevCapture);\n\n        if (capture) {\n          var currCaptureString = capture[0];\n          source = source.substring(currCaptureString.length);\n          var parsed = rule.parse(capture, nestedParse, state); // We also let rules override the default type of\n          // their parsed node if they would like to, so that\n          // there can be a single output function for all links,\n          // even if there are several rules to parse them.\n\n          if (parsed.type == null) {\n            parsed.type = ruleType;\n          }\n\n          result.push(parsed);\n          prevCapture = currCaptureString;\n          break;\n        }\n\n        i++;\n      }\n    }\n\n    return result;\n  }\n\n  return function outerParse(source, state) {\n    return nestedParse(normalizeWhitespace(source), state);\n  };\n} // Creates a match function for an inline scoped or simple element from a regex\n\n\nfunction inlineRegex(regex) {\n  return function match(source, state) {\n    if (state.inline) {\n      return regex.exec(source);\n    } else {\n      return null;\n    }\n  };\n} // basically any inline element except links\n\n\nfunction simpleInlineRegex(regex) {\n  return function match(source, state) {\n    if (state.inline || state.simple) {\n      return regex.exec(source);\n    } else {\n      return null;\n    }\n  };\n} // Creates a match function for a block scoped element from a regex\n\n\nfunction blockRegex(regex) {\n  return function match(source, state) {\n    if (state.inline || state.simple) {\n      return null;\n    } else {\n      return regex.exec(source);\n    }\n  };\n} // Creates a match function from a regex, ignoring block/inline scope\n\n\nfunction anyScopeRegex(regex) {\n  return function match(source\n  /*, state*/\n  ) {\n    return regex.exec(source);\n  };\n}\n\nfunction reactFor(outputFunc) {\n  return function nestedReactOutput(ast, state) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (Array.isArray(ast)) {\n      var oldKey = state.key;\n      var result = []; // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n\n      var lastWasString = false;\n\n      for (var i = 0; i < ast.length; i++) {\n        state.key = i;\n        var nodeOut = nestedReactOutput(ast[i], state);\n        var isString = typeof nodeOut === 'string';\n\n        if (isString && lastWasString) {\n          result[result.length - 1] += nodeOut;\n        } else {\n          result.push(nodeOut);\n        }\n\n        lastWasString = isString;\n      }\n\n      state.key = oldKey;\n      return result;\n    }\n\n    return outputFunc(ast, nestedReactOutput, state);\n  };\n}\n\nfunction sanitizeUrl(url) {\n  try {\n    var decoded = decodeURIComponent(url).replace(/[^A-Za-z0-9/:]/g, '');\n\n    if (decoded.match(/^\\s*(javascript|vbscript|data):/i)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('Anchor URL contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.', decoded);\n      }\n\n      return null;\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('Anchor URL could not be decoded due to malformed syntax or characters, it will not be rendered.', url);\n    } // decodeURIComponent sometimes throws a URIError\n    // See `decodeURIComponent('a%AFc');`\n    // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n\n\n    return null;\n  }\n\n  return url;\n}\n\nfunction unescapeUrl(rawUrlString) {\n  return rawUrlString.replace(UNESCAPE_URL_R, '$1');\n}\n/**\r\n * Everything inline, including links.\r\n */\n\n\nfunction parseInline(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  var isCurrentlySimple = state.simple || false;\n  state.inline = true;\n  state.simple = true;\n  var result = parse(content, state);\n  state.inline = isCurrentlyInline;\n  state.simple = isCurrentlySimple;\n  return result;\n}\n/**\r\n * Anything inline that isn't a link.\r\n */\n\n\nfunction parseSimpleInline(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  var isCurrentlySimple = state.simple || false;\n  state.inline = false;\n  state.simple = true;\n  var result = parse(content, state);\n  state.inline = isCurrentlyInline;\n  state.simple = isCurrentlySimple;\n  return result;\n}\n\nfunction parseBlock(parse, content, state) {\n  state.inline = false;\n  return parse(content + '\\n\\n', state);\n}\n\nvar parseCaptureInline = function parseCaptureInline(capture, parse, state) {\n  return {\n    content: parseInline(parse, capture[1], state)\n  };\n};\n\nfunction captureNothing() {\n  return {};\n}\n\nfunction renderNothing() {\n  return null;\n}\n\nfunction ruleOutput(rules) {\n  return function nestedRuleOutput(ast, outputFunc, state) {\n    return rules[ast.type].react(ast, outputFunc, state);\n  };\n}\n\nfunction cx() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return args.filter(Boolean).join(' ');\n}\n\nfunction get(src, path, fb) {\n  var ptr = src;\n  var frags = path.split('.');\n\n  while (frags.length) {\n    ptr = ptr[frags[0]];\n    if (ptr === undefined) break;else frags.shift();\n  }\n\n  return ptr || fb;\n}\n\nfunction getTag(tag, overrides) {\n  var override = get(overrides, tag);\n  if (!override) return tag;\n  return typeof override === 'function' || typeof override === 'object' && 'render' in override ? override : get(overrides, tag + \".component\", tag);\n}\n\nvar Priority;\n\n(function (Priority) {\n  /**\r\n   * anything that must scan the tree before everything else\r\n   */\n  Priority[Priority[\"MAX\"] = 0] = \"MAX\";\n  /**\r\n   * scans for block-level constructs\r\n   */\n\n  Priority[Priority[\"HIGH\"] = 1] = \"HIGH\";\n  /**\r\n   * inline w/ more priority than other inline\r\n   */\n\n  Priority[Priority[\"MED\"] = 2] = \"MED\";\n  /**\r\n   * inline elements\r\n   */\n\n  Priority[Priority[\"LOW\"] = 3] = \"LOW\";\n  /**\r\n   * bare text and stuff that is considered leftovers\r\n   */\n\n  Priority[Priority[\"MIN\"] = 4] = \"MIN\";\n})(Priority || (Priority = {}));\n\nfunction compiler(markdown, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options.overrides = options.overrides || {};\n  options.slugify = options.slugify || slugify;\n  options.namedCodesToUnicode = options.namedCodesToUnicode ? _extends({}, namedCodesToUnicode, options.namedCodesToUnicode) : namedCodesToUnicode;\n  var createElementFn = options.createElement || React.createElement; // eslint-disable-next-line no-unused-vars\n\n  function h( // locally we always will render a known string tag\n  tag, props) {\n    var overrideProps = get(options.overrides, tag + \".props\", {});\n\n    for (var _len2 = arguments.length, children = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      children[_key2 - 2] = arguments[_key2];\n    }\n\n    return createElementFn.apply(void 0, [getTag(tag, options.overrides), _extends({}, props, overrideProps, {\n      className: cx(props === null || props === void 0 ? void 0 : props.className, overrideProps.className) || undefined\n    })].concat(children));\n  }\n\n  function compile(input) {\n    var inline = false;\n\n    if (options.forceInline) {\n      inline = true;\n    } else if (!options.forceBlock) {\n      /**\r\n       * should not contain any block-level markdown like newlines, lists, headings,\r\n       * thematic breaks, blockquotes, tables, etc\r\n       */\n      inline = SHOULD_RENDER_AS_BLOCK_R.test(input) === false;\n    }\n\n    var arr = emitter(parser(inline ? input : input.replace(TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R, '') + \"\\n\\n\", {\n      inline: inline\n    }));\n\n    if (options.wrapper === null) {\n      return arr;\n    }\n\n    var wrapper = options.wrapper || (inline ? 'span' : 'div');\n    var jsx;\n\n    if (arr.length > 1 || options.forceWrapper) {\n      jsx = arr;\n    } else if (arr.length === 1) {\n      jsx = arr[0]; // TODO: remove this for React 16\n\n      if (typeof jsx === 'string') {\n        return h(\"span\", {\n          key: \"outer\"\n        }, jsx);\n      } else {\n        return jsx;\n      }\n    } else {\n      // TODO: return null for React 16\n      jsx = null;\n    }\n\n    return React.createElement(wrapper, {\n      key: 'outer'\n    }, jsx);\n  }\n\n  function attrStringToMap(str) {\n    var attributes = str.match(ATTR_EXTRACTOR_R);\n    return attributes ? attributes.reduce(function (map, raw, index) {\n      var delimiterIdx = raw.indexOf('=');\n\n      if (delimiterIdx !== -1) {\n        var key = normalizeAttributeKey(raw.slice(0, delimiterIdx)).trim();\n        var value = unquote(raw.slice(delimiterIdx + 1).trim());\n        var mappedKey = ATTRIBUTE_TO_JSX_PROP_MAP[key] || key;\n        var normalizedValue = map[mappedKey] = attributeValueToJSXPropValue(key, value);\n\n        if (typeof normalizedValue === 'string' && (HTML_BLOCK_ELEMENT_R.test(normalizedValue) || HTML_SELF_CLOSING_ELEMENT_R.test(normalizedValue))) {\n          map[mappedKey] = React.cloneElement(compile(normalizedValue.trim()), {\n            key: index\n          });\n        }\n      } else if (raw !== 'style') {\n        map[ATTRIBUTE_TO_JSX_PROP_MAP[raw] || raw] = true;\n      }\n\n      return map;\n    }, {}) : undefined;\n  }\n\n  function stripHtmlComments(html) {\n    return html.replace(/<!--[\\s\\S]*?(?:-->)/g, '');\n  }\n  /* istanbul ignore next */\n\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof markdown !== 'string') {\n      throw new Error(\"markdown-to-jsx: the first argument must be\\n                             a string\");\n    }\n\n    if (Object.prototype.toString.call(options.overrides) !== '[object Object]') {\n      throw new Error(\"markdown-to-jsx: options.overrides (second argument property) must be\\n                             undefined or an object literal with shape:\\n                             {\\n                                htmltagname: {\\n                                    component: string|ReactComponent(optional),\\n                                    props: object(optional)\\n                                }\\n                             }\");\n    }\n  }\n\n  var footnotes = [];\n  var refs = {};\n  /**\r\n   * each rule's react() output function goes through our custom h() JSX pragma;\r\n   * this allows the override functionality to be automatically applied\r\n   */\n\n  var rules = {\n    blockQuote: {\n      match: blockRegex(BLOCKQUOTE_R),\n      order: Priority.HIGH,\n      parse: function parse(capture, _parse, state) {\n        return {\n          content: _parse(capture[0].replace(BLOCKQUOTE_TRIM_LEFT_MULTILINE_R, ''), state)\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"blockquote\", {\n          key: state.key\n        }, output(node.content, state));\n      }\n    },\n    breakLine: {\n      match: anyScopeRegex(BREAK_LINE_R),\n      order: Priority.HIGH,\n      parse: captureNothing,\n      react: function react(_, __, state) {\n        return h(\"br\", {\n          key: state.key\n        });\n      }\n    },\n    breakThematic: {\n      match: blockRegex(BREAK_THEMATIC_R),\n      order: Priority.HIGH,\n      parse: captureNothing,\n      react: function react(_, __, state) {\n        return h(\"hr\", {\n          key: state.key\n        });\n      }\n    },\n    codeBlock: {\n      match: blockRegex(CODE_BLOCK_R),\n      order: Priority.MAX,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          content: capture[0].replace(/^ {4}/gm, '').replace(/\\n+$/, ''),\n          lang: undefined\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"pre\", {\n          key: state.key\n        }, h(\"code\", {\n          className: node.lang ? \"lang-\" + node.lang : ''\n        }, node.content));\n      }\n    },\n    codeFenced: {\n      match: blockRegex(CODE_BLOCK_FENCED_R),\n      order: Priority.MAX,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          content: capture[3],\n          lang: capture[2] || undefined,\n          type: 'codeBlock'\n        };\n      }\n    },\n    codeInline: {\n      match: simpleInlineRegex(CODE_INLINE_R),\n      order: Priority.LOW,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          content: capture[2]\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"code\", {\n          key: state.key\n        }, node.content);\n      }\n    },\n\n    /**\r\n     * footnotes are emitted at the end of compilation in a special <footer> block\r\n     */\n    footnote: {\n      match: blockRegex(FOOTNOTE_R),\n      order: Priority.MAX,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        footnotes.push({\n          footnote: capture[2],\n          identifier: capture[1]\n        });\n        return {};\n      },\n      react: renderNothing\n    },\n    footnoteReference: {\n      match: inlineRegex(FOOTNOTE_REFERENCE_R),\n      order: Priority.HIGH,\n      parse: function parse(capture\n      /*, parse*/\n      ) {\n        return {\n          content: capture[1],\n          target: \"#\" + options.slugify(capture[1])\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"a\", {\n          key: state.key,\n          href: sanitizeUrl(node.target)\n        }, h(\"sup\", {\n          key: state.key\n        }, node.content));\n      }\n    },\n    gfmTask: {\n      match: inlineRegex(GFM_TASK_R),\n      order: Priority.HIGH,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          completed: capture[1].toLowerCase() === 'x'\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"input\", {\n          checked: node.completed,\n          key: state.key,\n          readOnly: true,\n          type: \"checkbox\"\n        });\n      }\n    },\n    heading: {\n      match: blockRegex(HEADING_R),\n      order: Priority.HIGH,\n      parse: function parse(capture, _parse2, state) {\n        return {\n          content: parseInline(_parse2, capture[2], state),\n          id: options.slugify(capture[2]),\n          level: capture[1].length\n        };\n      },\n      react: function react(node, output, state) {\n        node.tag = \"h\" + node.level;\n        return h(node.tag, {\n          id: node.id,\n          key: state.key\n        }, output(node.content, state));\n      }\n    },\n    headingSetext: {\n      match: blockRegex(HEADING_SETEXT_R),\n      order: Priority.MAX,\n      parse: function parse(capture, _parse3, state) {\n        return {\n          content: parseInline(_parse3, capture[1], state),\n          level: capture[2] === '=' ? 1 : 2,\n          type: 'heading'\n        };\n      }\n    },\n    htmlComment: {\n      match: anyScopeRegex(HTML_COMMENT_R),\n      order: Priority.HIGH,\n      parse: function parse() {\n        return {};\n      },\n      react: renderNothing\n    },\n    image: {\n      match: simpleInlineRegex(IMAGE_R),\n      order: Priority.HIGH,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          alt: capture[1],\n          target: unescapeUrl(capture[2]),\n          title: capture[3]\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"img\", {\n          key: state.key,\n          alt: node.alt || undefined,\n          title: node.title || undefined,\n          src: sanitizeUrl(node.target)\n        });\n      }\n    },\n    link: {\n      match: inlineRegex(LINK_R),\n      order: Priority.LOW,\n      parse: function parse(capture, _parse4, state) {\n        return {\n          content: parseSimpleInline(_parse4, capture[1], state),\n          target: unescapeUrl(capture[2]),\n          title: capture[3]\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"a\", {\n          key: state.key,\n          href: sanitizeUrl(node.target),\n          title: node.title\n        }, output(node.content, state));\n      }\n    },\n    // https://daringfireball.net/projects/markdown/syntax#autolink\n    linkAngleBraceStyleDetector: {\n      match: inlineRegex(LINK_AUTOLINK_R),\n      order: Priority.MAX,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          content: [{\n            content: capture[1],\n            type: 'text'\n          }],\n          target: capture[1],\n          type: 'link'\n        };\n      }\n    },\n    linkBareUrlDetector: {\n      match: inlineRegex(LINK_AUTOLINK_BARE_URL_R),\n      order: Priority.MAX,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          content: [{\n            content: capture[1],\n            type: 'text'\n          }],\n          target: capture[1],\n          title: undefined,\n          type: 'link'\n        };\n      }\n    },\n    linkMailtoDetector: {\n      match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n      order: Priority.MAX,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        var address = capture[1];\n        var target = capture[1]; // Check for a `mailto:` already existing in the link:\n\n        if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n          target = 'mailto:' + target;\n        }\n\n        return {\n          content: [{\n            content: address.replace('mailto:', ''),\n            type: 'text'\n          }],\n          target: target,\n          type: 'link'\n        };\n      }\n    },\n    list: {\n      match: function match(source, state, prevCapture) {\n        // We only want to break into a list if we are at the start of a\n        // line. This is to avoid parsing \"hi * there\" with \"* there\"\n        // becoming a part of a list.\n        // You might wonder, \"but that's inline, so of course it wouldn't\n        // start a list?\". You would be correct! Except that some of our\n        // lists can be inline, because they might be inside another list,\n        // in which case we can parse with inline scope, but need to allow\n        // nested lists inside this inline scope.\n        var isStartOfLine = LIST_LOOKBEHIND_R.exec(prevCapture);\n        var isListBlock = state._list || !state.inline;\n\n        if (isStartOfLine && isListBlock) {\n          source = isStartOfLine[1] + source;\n          return LIST_R.exec(source);\n        } else {\n          return null;\n        }\n      },\n      order: Priority.HIGH,\n      parse: function parse(capture, _parse5, state) {\n        var bullet = capture[2];\n        var ordered = bullet.length > 1;\n        var start = ordered ? +bullet : undefined;\n        var items = capture[0] // recognize the end of a paragraph block inside a list item:\n        // two or more newlines at end end of the item\n        .replace(BLOCK_END_R, '\\n').match(LIST_ITEM_R);\n        var lastItemWasAParagraph = false;\n        var itemContent = items.map(function (item, i) {\n          // We need to see how far indented the item is:\n          var space = LIST_ITEM_PREFIX_R.exec(item)[0].length; // And then we construct a regex to \"unindent\" the subsequent\n          // lines of the items by that amount:\n\n          var spaceRegex = new RegExp('^ {1,' + space + '}', 'gm'); // Before processing the item, we need a couple things\n\n          var content = item // remove indents on trailing lines:\n          .replace(spaceRegex, '') // remove the bullet:\n          .replace(LIST_ITEM_PREFIX_R, ''); // Handling \"loose\" lists, like:\n          //\n          //  * this is wrapped in a paragraph\n          //\n          //  * as is this\n          //\n          //  * as is this\n\n          var isLastItem = i === items.length - 1;\n          var containsBlocks = content.indexOf('\\n\\n') !== -1; // Any element in a list is a block if it contains multiple\n          // newlines. The last element in the list can also be a block\n          // if the previous item in the list was a block (this is\n          // because non-last items in the list can end with \\n\\n, but\n          // the last item can't, so we just \"inherit\" this property\n          // from our previous element).\n\n          var thisItemIsAParagraph = containsBlocks || isLastItem && lastItemWasAParagraph;\n          lastItemWasAParagraph = thisItemIsAParagraph; // backup our state for restoration afterwards. We're going to\n          // want to set state._list to true, and state.inline depending\n          // on our list's looseness.\n\n          var oldStateInline = state.inline;\n          var oldStateList = state._list;\n          state._list = true; // Parse inline if we're in a tight list, or block if we're in\n          // a loose list.\n\n          var adjustedContent;\n\n          if (thisItemIsAParagraph) {\n            state.inline = false;\n            adjustedContent = content.replace(LIST_ITEM_END_R, '\\n\\n');\n          } else {\n            state.inline = true;\n            adjustedContent = content.replace(LIST_ITEM_END_R, '');\n          }\n\n          var result = _parse5(adjustedContent, state); // Restore our state before returning\n\n\n          state.inline = oldStateInline;\n          state._list = oldStateList;\n          return result;\n        });\n        return {\n          items: itemContent,\n          ordered: ordered,\n          start: start\n        };\n      },\n      react: function react(node, output, state) {\n        var Tag = node.ordered ? 'ol' : 'ul';\n        return h(Tag, {\n          key: state.key,\n          start: node.start\n        }, node.items.map(function generateListItem(item, i) {\n          return h(\"li\", {\n            key: i\n          }, output(item, state));\n        }));\n      }\n    },\n    newlineCoalescer: {\n      match: blockRegex(CONSECUTIVE_NEWLINE_R),\n      order: Priority.LOW,\n      parse: captureNothing,\n      react: function react()\n      /*node, output, state*/\n      {\n        return '\\n';\n      }\n    },\n    paragraph: {\n      match: blockRegex(PARAGRAPH_R),\n      order: Priority.LOW,\n      parse: parseCaptureInline,\n      react: function react(node, output, state) {\n        return h(\"p\", {\n          key: state.key\n        }, output(node.content, state));\n      }\n    },\n    ref: {\n      match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n      order: Priority.MAX,\n      parse: function parse(capture\n      /*, parse*/\n      ) {\n        refs[capture[1]] = {\n          target: capture[2],\n          title: capture[4]\n        };\n        return {};\n      },\n      react: renderNothing\n    },\n    refImage: {\n      match: simpleInlineRegex(REFERENCE_IMAGE_R),\n      order: Priority.MAX,\n      parse: function parse(capture) {\n        return {\n          alt: capture[1] || undefined,\n          ref: capture[2]\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"img\", {\n          key: state.key,\n          alt: node.alt,\n          src: sanitizeUrl(refs[node.ref].target),\n          title: refs[node.ref].title\n        });\n      }\n    },\n    refLink: {\n      match: inlineRegex(REFERENCE_LINK_R),\n      order: Priority.MAX,\n      parse: function parse(capture, _parse6, state) {\n        return {\n          content: _parse6(capture[1], state),\n          fallbackContent: _parse6(capture[0].replace(SQUARE_BRACKETS_R, '\\\\$1'), state),\n          ref: capture[2]\n        };\n      },\n      react: function react(node, output, state) {\n        return refs[node.ref] ? h(\"a\", {\n          key: state.key,\n          href: sanitizeUrl(refs[node.ref].target),\n          title: refs[node.ref].title\n        }, output(node.content, state)) : h(\"span\", {\n          key: state.key\n        }, output(node.fallbackContent, state));\n      }\n    },\n    table: {\n      match: blockRegex(NP_TABLE_R),\n      order: Priority.HIGH,\n      parse: parseTable,\n      react: function react(node, output, state) {\n        return h(\"table\", {\n          key: state.key\n        }, h(\"thead\", null, h(\"tr\", null, node.header.map(function generateHeaderCell(content, i) {\n          return h(\"th\", {\n            key: i,\n            style: getTableStyle(node, i)\n          }, output(content, state));\n        }))), h(\"tbody\", null, node.cells.map(function generateTableRow(row, i) {\n          return h(\"tr\", {\n            key: i\n          }, row.map(function generateTableCell(content, c) {\n            return h(\"td\", {\n              key: c,\n              style: getTableStyle(node, c)\n            }, output(content, state));\n          }));\n        })));\n      }\n    },\n    tableSeparator: {\n      match: function match(source, state) {\n        if (!state.inTable) {\n          return null;\n        }\n\n        return TABLE_SEPARATOR_R.exec(source);\n      },\n      order: Priority.HIGH,\n      parse: function parse() {\n        return {\n          type: 'tableSeparator'\n        };\n      },\n      // These shouldn't be reached, but in case they are, be reasonable:\n      react: function react() {\n        return ' | ';\n      }\n    },\n    text: {\n      // Here we look for anything followed by non-symbols,\n      // double newlines, or double-space-newlines\n      // We break on any symbol characters so that this grammar\n      // is easy to extend without needing to modify this regex\n      match: anyScopeRegex(TEXT_PLAIN_R),\n      order: Priority.MIN,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          content: capture[0] // nbsp -> unicode equivalent for named chars\n          .replace(HTML_CHAR_CODE_R, function (full, inner) {\n            return options.namedCodesToUnicode[inner] ? options.namedCodesToUnicode[inner] : full;\n          })\n        };\n      },\n      react: function react(node\n      /*, output, state*/\n      ) {\n        return node.content;\n      }\n    },\n    textBolded: {\n      match: simpleInlineRegex(TEXT_BOLD_R),\n      order: Priority.MED,\n      parse: function parse(capture, _parse7, state) {\n        return {\n          // capture[1] -> the syntax control character\n          // capture[2] -> inner content\n          content: _parse7(capture[2], state)\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"strong\", {\n          key: state.key\n        }, output(node.content, state));\n      }\n    },\n    textEmphasized: {\n      match: simpleInlineRegex(TEXT_EMPHASIZED_R),\n      order: Priority.LOW,\n      parse: function parse(capture, _parse8, state) {\n        return {\n          // capture[1] -> opening * or _\n          // capture[2] -> inner content\n          content: _parse8(capture[2], state)\n        };\n      },\n      react: function react(node, output, state) {\n        return h(\"em\", {\n          key: state.key\n        }, output(node.content, state));\n      }\n    },\n    textEscaped: {\n      // We don't allow escaping numbers, letters, or spaces here so that\n      // backslashes used in plain text still get rendered. But allowing\n      // escaping anything else provides a very flexible escape mechanism,\n      // regardless of how this grammar is extended.\n      match: simpleInlineRegex(TEXT_ESCAPED_R),\n      order: Priority.HIGH,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          content: capture[1],\n          type: 'text'\n        };\n      }\n    },\n    textStrikethroughed: {\n      match: simpleInlineRegex(TEXT_STRIKETHROUGHED_R),\n      order: Priority.LOW,\n      parse: parseCaptureInline,\n      react: function react(node, output, state) {\n        return h(\"del\", {\n          key: state.key\n        }, output(node.content, state));\n      }\n    }\n  }; // Object.keys(rules).forEach(key => {\n  //     let { match, parse } = rules[key];\n  //     rules[key].match = (...args) => {\n  //         const start = performance.now();\n  //         const result = match(...args);\n  //         const delta = performance.now() - start;\n  //         if (delta > 5)\n  //             console.warn(\n  //                 `Slow match for ${key}: ${delta.toFixed(3)}ms, input: ${\n  //                     args[0]\n  //                 }`\n  //             );\n  //         return result;\n  //     };\n  //     rules[key].parse = (...args) => {\n  //         const start = performance.now();\n  //         const result = parse(...args);\n  //         const delta = performance.now() - start;\n  //         if (delta > 5)\n  //             console.warn(`Slow parse for ${key}: ${delta.toFixed(3)}ms`);\n  //         console.log(`${key}:parse`, `${delta.toFixed(3)}ms`, args[0]);\n  //         return result;\n  //     };\n  // });\n\n  if (options.disableParsingRawHTML !== true) {\n    rules.htmlBlock = {\n      /**\r\n       * find the first matching end tag and process the interior\r\n       */\n      match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n      order: Priority.HIGH,\n      parse: function parse(capture, _parse9, state) {\n        var _capture$3$match = capture[3].match(HTML_LEFT_TRIM_AMOUNT_R),\n            whitespace = _capture$3$match[1];\n\n        var trimmer = new RegExp(\"^\" + whitespace, 'gm');\n        var trimmed = capture[3].replace(trimmer, '');\n        var parseFunc = containsBlockSyntax(trimmed) ? parseBlock : parseInline;\n        var tagName = capture[1].toLowerCase();\n        var noInnerParse = DO_NOT_PROCESS_HTML_ELEMENTS.indexOf(tagName) !== -1;\n        return {\n          attrs: attrStringToMap(capture[2]),\n\n          /**\r\n           * if another html block is detected within, parse as block,\r\n           * otherwise parse as inline to pick up any further markdown\r\n           */\n          content: noInnerParse ? capture[3] : parseFunc(_parse9, trimmed, state),\n          noInnerParse: noInnerParse,\n          tag: noInnerParse ? tagName : capture[1]\n        };\n      },\n      react: function react(node, output, state) {\n        return (// @ts-ignore\n          h(node.tag, Object.assign({\n            key: state.key\n          }, node.attrs), node.noInnerParse ? node.content : output(node.content, state))\n        );\n      }\n    };\n    rules.htmlSelfClosing = {\n      /**\r\n       * find the first matching end tag and process the interior\r\n       */\n      match: anyScopeRegex(HTML_SELF_CLOSING_ELEMENT_R),\n      order: Priority.HIGH,\n      parse: function parse(capture\n      /*, parse, state*/\n      ) {\n        return {\n          attrs: attrStringToMap(capture[2] || ''),\n          tag: capture[1]\n        };\n      },\n      react: function react(node, output, state) {\n        return h(node.tag, Object.assign({}, node.attrs, {\n          key: state.key\n        }));\n      }\n    };\n  }\n\n  var parser = parserFor(rules);\n  var emitter = reactFor(ruleOutput(rules));\n  var jsx = compile(stripHtmlComments(markdown));\n\n  if (footnotes.length) {\n    jsx.props.children.push(h(\"footer\", {\n      key: \"footer\"\n    }, footnotes.map(function createFootnote(def) {\n      return h(\"div\", {\n        id: options.slugify(def.identifier),\n        key: def.identifier\n      }, def.identifier, emitter(parser(def.footnote, {\n        inline: true\n      })));\n    })));\n  }\n\n  return jsx;\n}\n/**\r\n * A simple HOC for easy React use. Feed the markdown content as a direct child\r\n * and the rest is taken care of automatically.\r\n */\n\n\nvar Markdown = function Markdown(_ref) {\n  var children = _ref.children,\n      options = _ref.options,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\", \"options\"]);\n\n  return React.cloneElement(compiler(children, options), props);\n};\n\nvar MarkdownTextArea = function MarkdownTextArea(_ref) {\n  var fieldId = _ref.fieldId,\n      placeholder = _ref.placeholder,\n      formId = _ref.formId;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      defaultValues = _useForm.defaultValues,\n      registerField = _useForm.registerField;\n\n  useEffect(function () {\n    var _defaultValues$formId, _defaultValues$formId2;\n\n    var defaultValue = (_defaultValues$formId = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId2 = defaultValues[formId]) === null || _defaultValues$formId2 === void 0 ? void 0 : _defaultValues$formId2[fieldId]) !== null && _defaultValues$formId !== void 0 ? _defaultValues$formId : '';\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null;\n  return React.createElement(\"div\", {\n    className: \"fresh-markdown-wrapper\"\n  }, React.createElement(\"textarea\", {\n    id: \"fresh-\" + fieldId,\n    placeholder: placeholder,\n    value: data[formId][fieldId],\n    className: \"fresh-input fresh-input-textarea\",\n    onChange: function onChange(e) {\n      return setField(fieldId, e.target.value, formId);\n    }\n  }), React.createElement(\"div\", {\n    className: \"fresh-input fresh-input-markdown\"\n  }, React.createElement(Markdown, {\n    children: data[formId][fieldId] || ''\n  })));\n};\n\nvar Text = function Text(_ref) {\n  var className = _ref.className,\n      fieldId = _ref.fieldId,\n      placeholder = _ref.placeholder,\n      required = _ref.required,\n      type = _ref.type,\n      formId = _ref.formId;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      registerField = _useForm.registerField,\n      defaultValues = _useForm.defaultValues;\n\n  useEffect(function () {\n    var _defaultValues$formId, _defaultValues$formId2;\n\n    var defaultValue = (_defaultValues$formId = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId2 = defaultValues[formId]) === null || _defaultValues$formId2 === void 0 ? void 0 : _defaultValues$formId2[fieldId]) !== null && _defaultValues$formId !== void 0 ? _defaultValues$formId : '';\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null;\n  return React.createElement(\"input\", {\n    required: required,\n    className: \"fresh-input fresh-input-\" + type + \" \" + className,\n    placeholder: placeholder,\n    id: \"fresh-\" + fieldId + \"-\" + formId,\n    type: type,\n    value: data[formId][fieldId],\n    onChange: function onChange(e) {\n      return setField(fieldId, e.target.value, formId);\n    }\n  });\n};\n\nvar Toggle = function Toggle(_ref) {\n  var fieldId = _ref.fieldId,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      formId = _ref.formId;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      setField = _useForm.setField,\n      defaultValues = _useForm.defaultValues,\n      registerField = _useForm.registerField;\n\n  useEffect(function () {\n    var _defaultValues$formId, _defaultValues$formId2;\n\n    var defaultValue = (_defaultValues$formId = defaultValues === null || defaultValues === void 0 ? void 0 : (_defaultValues$formId2 = defaultValues[formId]) === null || _defaultValues$formId2 === void 0 ? void 0 : _defaultValues$formId2[fieldId]) !== null && _defaultValues$formId !== void 0 ? _defaultValues$formId : false;\n    registerField(fieldId, defaultValue, formId);\n  }, []);\n  if (!(fieldId in data[formId])) return null;\n  return React.createElement(\"div\", {\n    className: className + \" fresh-switch\"\n  }, React.createElement(\"input\", {\n    checked: data[formId][fieldId] || false,\n    type: \"checkbox\",\n    id: \"fresh-\" + fieldId,\n    className: \"fresh-input-toggle\",\n    onChange: function onChange(_) {\n      return setField(fieldId, !data[formId][fieldId], formId);\n    }\n  }), React.createElement(\"span\", {\n    className: \"fresh-slider \" + (data[formId][fieldId] ? \"on\" : ''),\n    onChange: function onChange(_) {\n      return setField(fieldId, !data[formId][fieldId], formId);\n    }\n  }));\n};\n\nvar camelCase = function camelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w|\\s+)/g, function (match, index) {\n    if (+match === 0) return '';\n    return index == 0 ? match.toLowerCase() : match.toUpperCase();\n  });\n};\n\nvar Field = function Field(_ref) {\n  var _ref$required = _ref.required,\n      required = _ref$required === void 0 ? false : _ref$required,\n      children = _ref.children,\n      _ref$name = _ref.name,\n      name = _ref$name === void 0 ? '' : _ref$name,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? 'text' : _ref$type,\n      _ref$label = _ref.label,\n      label = _ref$label === void 0 ? true : _ref$label,\n      error = _ref.error,\n      _ref$placeholder = _ref.placeholder,\n      placeholder = _ref$placeholder === void 0 ? '' : _ref$placeholder,\n      options = _ref.options,\n      strength = _ref.strength,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      _ref$defaultValue = _ref.defaultValue,\n      defaultValue = _ref$defaultValue === void 0 ? '' : _ref$defaultValue,\n      _ref$displayProperty = _ref.displayProperty,\n      displayProperty = _ref$displayProperty === void 0 ? '' : _ref$displayProperty,\n      _ref$valueProperty = _ref.valueProperty,\n      valueProperty = _ref$valueProperty === void 0 ? '' : _ref$valueProperty,\n      _ref$keyProperty = _ref.keyProperty,\n      keyProperty = _ref$keyProperty === void 0 ? 'id' : _ref$keyProperty,\n      tooltip = _ref.tooltip,\n      _ref$readOnly = _ref.readOnly,\n      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,\n      _ref$wrapperStyle = _ref.wrapperStyle,\n      wrapperStyle = _ref$wrapperStyle === void 0 ? {} : _ref$wrapperStyle;\n  var fieldId = name || camelCase(children);\n\n  var _useContext = useContext(FormContext),\n      formId = _useContext.formId;\n\n  var standardProps = {\n    children: children,\n    required: required,\n    name: name,\n    type: type,\n    label: label,\n    error: error,\n    placeholder: placeholder,\n    options: options,\n    className: className,\n    defaultValue: defaultValue,\n    displayProperty: displayProperty,\n    readOnly: readOnly,\n    formId: formId\n  };\n  return React.createElement(\"div\", {\n    className: \"fresh-field-wrapper \" + fieldId,\n    style: wrapperStyle\n  }, React.createElement(\"label\", {\n    className: \"fresh-label\",\n    htmlFor: \"fresh-\" + fieldId\n  }, React.createElement(\"span\", {\n    className: \"fresh-title\"\n  }, required && '*', \" \", label && children, \"\\xA0\", tooltip && React.createElement(Tooltip, {\n    tooltip: tooltip\n  })), function () {\n    switch (type) {\n      case 'select':\n        return React.createElement(Select, Object.assign({\n          fieldId: fieldId,\n          valueProperty: valueProperty\n        }, standardProps));\n\n      case 'reference':\n        return React.createElement(Reference, Object.assign({\n          fieldId: fieldId,\n          keyProperty: keyProperty\n        }, standardProps));\n\n      case 'password':\n        return React.createElement(Password, Object.assign({\n          strength: strength,\n          fieldId: fieldId\n        }, standardProps));\n\n      case 'tags':\n        return React.createElement(Tags, Object.assign({\n          fieldId: fieldId\n        }, standardProps));\n\n      case 'textarea':\n        return React.createElement(TextArea, Object.assign({\n          fieldId: fieldId\n        }, standardProps));\n\n      case 'number':\n        return React.createElement(NumberField, Object.assign({\n          fieldId: fieldId\n        }, standardProps));\n\n      case 'markdown':\n        return React.createElement(MarkdownTextArea, Object.assign({\n          fieldId: fieldId\n        }, standardProps));\n\n      case 'toggle':\n        return React.createElement(Toggle, Object.assign({\n          fieldId: fieldId\n        }, standardProps));\n\n      default:\n        return React.createElement(Text, Object.assign({\n          fieldId: fieldId\n        }, standardProps));\n    }\n  }()), error && React.createElement(\"div\", {\n    className: \"fresh-error\"\n  }, error));\n};\n\nField.defaultProps = {\n  defaultValue: null,\n  options: [],\n  tooltip: ''\n};\n\nvar Form = function Form(_ref) {\n  var _ref$cancelAction = _ref.cancelAction,\n      cancelAction = _ref$cancelAction === void 0 ? function () {\n    return null;\n  } : _ref$cancelAction,\n      _ref$onChange = _ref.onChange,\n      _onChange = _ref$onChange === void 0 ? null : _ref$onChange,\n      _ref$cancelButton = _ref.cancelButton,\n      cancelButton = _ref$cancelButton === void 0 ? true : _ref$cancelButton,\n      _ref$cancelText = _ref.cancelText,\n      cancelText = _ref$cancelText === void 0 ? 'Cancel' : _ref$cancelText,\n      children = _ref.children,\n      formId = _ref.formId,\n      _onSubmit = _ref.onSubmit,\n      _ref$submitText = _ref.submitText,\n      submitText = _ref$submitText === void 0 ? 'Submit' : _ref$submitText,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      _ref$defaultValues = _ref.defaultValues,\n      defaultValues = _ref$defaultValues === void 0 ? {} : _ref$defaultValues;\n\n  var _useForm = useForm(),\n      data = _useForm.data,\n      register = _useForm.register,\n      isReady = _useForm.isReady,\n      unregister = _useForm.unregister;\n\n  useEffect(function () {\n    register(defaultValues, formId);\n    return function () {\n      unregister(formId);\n    };\n  }, []);\n  if (!isReady[formId]) return null;\n  return React.createElement(FormContext.Provider, {\n    value: {\n      formId: formId\n    }\n  }, React.createElement(\"form\", {\n    className: className + \" fresh-form\",\n    onSubmit: function onSubmit(e) {\n      e.preventDefault();\n\n      _onSubmit(data[formId]);\n    },\n    onChange: function onChange() {\n      if (_onChange) _onChange(data[formId]);\n    }\n  }, children, React.createElement(\"div\", null, React.createElement(\"button\", {\n    id: \"fresh-submit\",\n    className: \"fresh-button fresh-submit\",\n    type: \"submit\"\n  }, submitText), cancelButton && React.createElement(CancelButton, {\n    formId: formId,\n    cancelAction: cancelAction,\n    cancelText: cancelText\n  }))));\n}; // TODO\n\n\nexport { Field, Form, useForm };","map":{"version":3,"sources":["../src/state/immer.ts","../src/state/formState.ts","../src/form/CancelButton.tsx","../src/form/Tooltip.tsx","../src/fields/Select.tsx","../src/fields/Reference.tsx","../src/fields/Password.tsx","../src/fields/Tags.tsx","../src/fields/TextArea.tsx","../src/fields/Number.tsx","../src/fields/MarkdownInput.tsx","../src/fields/Markdown.tsx","../src/fields/Text.tsx","../src/fields/Toggle.tsx","../src/Field.tsx","../src/index.tsx"],"names":["immer","config","set","produce","store","data","isReady","defaultValues","setForm","state","setField","setDefaults","register","unregister","registerField","resetForm","useForm","create","FormContext","React","CancelButton","cancelAction","cancelText","formId","id","className","onClick","type","Tooltip","tooltip","tooltipBackground","tooltipColor","tooltipIconColor","tooltipStyle","style","width","height","viewBox","fill","xmlns","fillRule","clipRule","d","PropTypes","string","Select","options","fieldId","displayProperty","valueProperty","useEffect","defaultValue","onChange","e","value","option","key","i","Reference","keyProperty","placeholder","inputValue","setInputValue","useState","isFocused","setIsFocused","onFocus","onBlur","padding","onMouseDown","Password","required","strength","strengthValue","calculateScore","strengthMeter","background","marginBottom","transition","showText","fieldPartialMatch","minimumLength","score","password","symbols","Tags","marginTop","TextArea","NumberField","parseInt","ATTRIBUTE_TO_JSX_PROP_MAP","accesskey","allowfullscreen","allowtransparency","autocomplete","autofocus","autoplay","cellpadding","cellspacing","charset","classid","colspan","contenteditable","contextmenu","crossorigin","enctype","formaction","formenctype","formmethod","formnovalidate","formtarget","frameborder","hreflang","inputmode","keyparams","keytype","marginheight","marginwidth","maxlength","mediagroup","minlength","novalidate","radiogroup","readonly","rowspan","spellcheck","srcdoc","srclang","srcset","tabindex","usemap","namedCodesToUnicode","amp","apos","gt","lt","nbsp","quot","DO_NOT_PROCESS_HTML_ELEMENTS","ATTR_EXTRACTOR_R","AUTOLINK_MAILTO_CHECK_R","BLOCK_END_R","BLOCKQUOTE_R","BLOCKQUOTE_TRIM_LEFT_MULTILINE_R","BREAK_LINE_R","BREAK_THEMATIC_R","CODE_BLOCK_FENCED_R","CODE_BLOCK_R","CODE_INLINE_R","CONSECUTIVE_NEWLINE_R","CR_NEWLINE_R","FOOTNOTE_R","FOOTNOTE_REFERENCE_R","FORMFEED_R","GFM_TASK_R","HEADING_R","HEADING_SETEXT_R","HTML_BLOCK_ELEMENT_R","HTML_CHAR_CODE_R","HTML_COMMENT_R","HTML_CUSTOM_ATTR_R","HTML_SELF_CLOSING_ELEMENT_R","INTERPOLATION_R","LINK_AUTOLINK_BARE_URL_R","LINK_AUTOLINK_MAILTO_R","LINK_AUTOLINK_R","LIST_ITEM_END_R","LIST_LOOKBEHIND_R","CAPTURE_LETTER_AFTER_HYPHEN","NP_TABLE_R","PARAGRAPH_R","REFERENCE_IMAGE_OR_LINK","REFERENCE_IMAGE_R","REFERENCE_LINK_R","SQUARE_BRACKETS_R","SHOULD_RENDER_AS_BLOCK_R","TAB_R","TABLE_SEPARATOR_R","TABLE_TRIM_PIPES","TABLE_CELL_END_TRIM","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","TABLE_RIGHT_ALIGN","TEXT_BOLD_R","TEXT_EMPHASIZED_R","TEXT_STRIKETHROUGHED_R","TEXT_ESCAPED_R","TEXT_PLAIN_R","TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R","HTML_LEFT_TRIM_AMOUNT_R","UNESCAPE_URL_R","LIST_BULLET","LIST_ITEM_PREFIX","LIST_ITEM_PREFIX_R","LIST_ITEM_R","LIST_R","LINK_INSIDE","LINK_HREF_AND_TITLE","LINK_R","IMAGE_R","BLOCK_SYNTAXES","r","str","prevInTable","tableRow","parse","source","cells","node","alignText","rowsText","parseTableRow","header","capture","align","parseTableAlign","parseTableCells","textAlign","hyphenIndex","letter","kvPair","camelCasedKey","substr","styles","sanitizeUrl","ruleList","Object","process","order","rules","isFinite","console","orderA","orderB","typeA","result","prevCapture","ruleType","rule","currCaptureString","parsed","nestedParse","normalizeWhitespace","regex","Array","oldKey","lastWasString","ast","nodeOut","nestedReactOutput","isString","outputFunc","decoded","decodeURIComponent","rawUrlString","isCurrentlyInline","isCurrentlySimple","content","parseCaptureInline","parseInline","args","ptr","frags","path","override","get","tag","Priority","compiler","markdown","createElementFn","children","overrideProps","getTag","cx","props","undefined","inline","arr","emitter","parser","input","wrapper","jsx","h","attributes","delimiterIdx","raw","normalizeAttributeKey","unquote","mappedKey","normalizedValue","map","attributeValueToJSXPropValue","compile","index","html","footnotes","refs","blockQuote","match","blockRegex","react","output","breakLine","anyScopeRegex","breakThematic","codeBlock","lang","codeFenced","codeInline","simpleInlineRegex","footnote","identifier","renderNothing","footnoteReference","inlineRegex","target","href","gfmTask","completed","checked","readOnly","heading","level","length","headingSetext","htmlComment","image","alt","unescapeUrl","title","src","link","parseSimpleInline","linkAngleBraceStyleDetector","linkBareUrlDetector","linkMailtoDetector","address","list","isStartOfLine","isListBlock","bullet","ordered","start","items","lastItemWasAParagraph","itemContent","space","spaceRegex","isLastItem","containsBlocks","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","Tag","newlineCoalescer","paragraph","ref","refImage","refLink","fallbackContent","table","getTableStyle","c","tableSeparator","text","textBolded","textEmphasized","textEscaped","textStrikethroughed","whitespace","trimmer","trimmed","parseFunc","containsBlockSyntax","tagName","noInnerParse","attrs","attrStringToMap","parserFor","reactFor","ruleOutput","stripHtmlComments","def","Markdown","MarkdownTextArea","Text","Toggle","camelCase","Field","name","label","error","wrapperStyle","useContext","standardProps","htmlFor","Form","cancelButton","onSubmit","submitText"],"mappings":"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","sourcesContent":["import produce from 'immer'\n\nexport const immer = (config) => (set, get) =>\n  config((fn) => set(produce(fn)), get)\n","import React from 'react'\nimport create from 'zustand'\nimport { immer } from './immer'\n\n// Woof on theses types.\n// TODO fix these types\nconst store = (set: (val: any) => any) => ({\n  data: {},\n  isReady: {},\n  defaultValues: {},\n  setForm: (formData: any, formId: string) =>\n    set((state: any) => {\n      state.data[formId] = { ...formData }\n    }),\n  setField: (id: string, value: any, formId: string) =>\n    set((state: any) => {\n      state.data[formId][id] = value\n    }),\n  setDefaults: (formData: any, formId: string) =>\n    set((state: any) => {\n      state.defaultValues[formId] = { ...formData }\n    }),\n  register: (formData: any, formId: string) =>\n    set((state: any) => {\n      state.data[formId] = { ...formData }\n      state.defaultValues[formId] = { ...formData }\n      state.isReady[formId] = true\n    }),\n  unregister: (formId: string) =>\n    set((state: any) => {\n      state.isReady[formId] = false\n    }),\n  registerField: (fieldId: string, defaultValue: any, formId: string) =>\n    set((state: any) => {\n      state.data[formId][fieldId] = defaultValue\n    }),\n  resetForm: (formId: string) =>\n    set((state: any) => {\n      state.data[formId] = state.defaultValues[formId]\n    }),\n})\n\nexport const useForm = create(immer(store))\n\nexport const FormContext = React.createContext(null)\n","import React from 'react'\nimport { useForm } from '../state/formState'\n\nconst CancelButton = ({\n  cancelAction,\n  cancelText = 'Cancel',\n  formId,\n}: Props) => {\n  const { data, setField, isReady, resetForm } = useForm()\n  return (\n    <button\n      id=\"fresh-cancel\"\n      className=\"fresh-button fresh-cancel\"\n      onClick={() => {\n        cancelAction(formId)\n        resetForm(formId)\n      }}\n      type=\"reset\"\n    >\n      {cancelText}\n    </button>\n  )\n}\n\ntype Props = {\n  cancelAction: (resetForm) => void\n  cancelText: string\n  formId: string\n}\nexport default CancelButton\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\ninterface TooltipInterface {\n  tooltip: string\n  tooltipBackground: string\n  tooltipColor: string\n  tooltipIconColor: string\n}\n\nconst Tooltip = ({\n  tooltip,\n  tooltipBackground,\n  tooltipColor,\n  tooltipIconColor,\n}: TooltipInterface) => {\n  const tooltipStyle = {\n    '--fresh-tooltip-background': tooltipBackground,\n    '--fresh-tooltip-color': tooltipColor,\n    '--fresh-tooltip-icon-color': tooltipIconColor,\n  } as React.CSSProperties\n  return (\n    <span className=\"fresh-tooltip\" data-tooltip={tooltip} style={tooltipStyle}>\n      <svg\n        className=\"fresh-tooltip-icon\"\n        width=\"16\"\n        height=\"16\"\n        viewBox=\"0 0 16 16\"\n        fill=\"none\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          clipRule=\"evenodd\"\n          d=\"M8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16ZM9.02539 5.91797H5.84668V7.79102H6.91309V11.127H5.84668V13H10.0098V11.127H9.02539V5.91797ZM6.89258 3.16309C6.83333 3.30892 6.80371 3.46615 6.80371 3.63477C6.80371 3.80339 6.83333 3.96289 6.89258 4.11328C6.95638 4.25911 7.04297 4.38672 7.15234 4.49609C7.26172 4.60547 7.38932 4.69206 7.53516 4.75586C7.68555 4.81966 7.84733 4.85156 8.02051 4.85156C8.18457 4.85156 8.33952 4.81966 8.48535 4.75586C8.63118 4.69206 8.75879 4.60547 8.86816 4.49609C8.97754 4.38672 9.06413 4.25911 9.12793 4.11328C9.19173 3.96289 9.22363 3.80339 9.22363 3.63477C9.22363 3.46615 9.19173 3.30892 9.12793 3.16309C9.06413 3.0127 8.97754 2.88281 8.86816 2.77344C8.75879 2.66406 8.63118 2.57747 8.48535 2.51367C8.33952 2.44987 8.18457 2.41797 8.02051 2.41797C7.84733 2.41797 7.68555 2.44987 7.53516 2.51367C7.38932 2.57747 7.26172 2.66406 7.15234 2.77344C7.04297 2.88281 6.95638 3.0127 6.89258 3.16309Z\"\n          fill={tooltipIconColor}\n        />\n      </svg>\n    </span>\n  )\n}\n\nTooltip.propTypes = {\n  tooltip: PropTypes.string,\n  tooltipBackground: PropTypes.string,\n  tooltipColor: PropTypes.string,\n  tooltipIconColor: PropTypes.string,\n}\n\nTooltip.defaultProps = {\n  tooltip: '',\n  tooltipBackground: '#eee',\n  tooltipColor: '#000',\n  tooltipIconColor: '#000',\n}\nexport default Tooltip\n","import React, { useEffect } from 'react'\nimport { FieldInterface } from './types'\nimport { useForm } from '../state/formState'\n\nconst Select = ({\n  options,\n  fieldId,\n  formId,\n  displayProperty = '',\n  valueProperty = '',\n  className = '',\n}: FieldInterface) => {\n  const { data, setField, registerField, defaultValues } = useForm()\n\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId]\n      ? defaultValues?.[formId]?.[fieldId]?.[valueProperty] ||\n        defaultValues?.[formId]?.[fieldId]\n      : options[0]\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <select\n      id={`fresh-${fieldId}-${formId}`}\n      className={`fresh-input fresh-input-select ${className}`}\n      onChange={e => setField(fieldId, e.target.value, formId)}\n      value={data[formId][fieldId]}\n    >\n      {options.map((option, i) => (\n        <option\n          value={option?.[valueProperty] || option}\n          key={`fresh-${fieldId}-${formId}-${i}`}\n          className=\"fresh-option\"\n        >\n          {option?.[displayProperty] || option}\n        </option>\n      ))}\n    </select>\n  )\n}\n\nexport default Select\n","import React, { useState, useEffect } from 'react'\nimport { useForm } from '../state/formState'\nimport { FieldInterface } from './types'\n\nconst Reference = ({\n  options,\n  fieldId,\n  keyProperty = 'id',\n  displayProperty,\n  placeholder = '',\n  className = '',\n  formId,\n}: FieldInterface) => {\n  const { data, setField, isReady, defaultValues, registerField } = useForm()\n  const [inputValue, setInputValue] = useState(defaultValues?.[formId]?.[fieldId]?.[displayProperty] || '')\n  const [isFocused, setIsFocused] = useState(false)\n\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  // If the form is not registered or there is not data object\n  if (!isReady) return null\n  return (\n    <>\n      <input\n        id={`fresh-${fieldId}-${formId}`}\n        onChange={e => setInputValue(e.target.value)}\n        value={inputValue}\n        onFocus={() => setIsFocused(true)}\n        onBlur={() => setIsFocused(false)}\n        placeholder={placeholder}\n        type=\"text\"\n        className={`fresh-input fresh-input-reference ${className}`}\n      />\n      {isFocused && (\n        <div className=\"fresh-focused\">\n          {options\n            .filter(option =>\n              option[displayProperty]\n                .toLowerCase()\n                .includes(inputValue.toLowerCase())\n            )\n            .map(option => (\n              <div\n                key={option[keyProperty]}\n                style={{ padding: '0.75em' }}\n                onMouseDown={() => {\n                  setField(fieldId, option, formId)\n                  setInputValue(option[displayProperty])\n                }}\n              >\n                {option[displayProperty]}\n              </div>\n            ))}\n        </div>\n      )}\n    </>\n  )\n}\n\nexport default Reference\n","import React, { useEffect } from 'react'\nimport { useForm } from '../state/formState'\nimport { FieldInterface } from './types'\n\nconst Password = ({\n  placeholder,\n  className = '',\n  required,\n  fieldId,\n  strength = true,\n  type,\n  formId,\n}: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n  // If the form is not registered or there is not data object\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  const strengthValue = calculateScore(data[formId][fieldId] ?? '')\n\n  let strengthMeter = {\n    background: '#ccc',\n    width: 'calc(193px * 0.25)',\n  }\n  if (strengthValue >= 2 && strengthValue < 3) {\n    strengthMeter = {\n      width: 'calc(193px * 0.5)',\n      background: 'red',\n    }\n  } else if (strengthValue >= 3 && strengthValue < 4) {\n    strengthMeter = {\n      width: 'calc(193px * 0.75)',\n      background: 'red',\n    }\n  } else if (strengthValue >= 4) {\n    strengthMeter = {\n      width: 'calc(193px * 1)',\n      background: 'green',\n    }\n  }\n  return (\n    <>\n      <input\n        className={`fresh-input fresh-input-password ${className}`}\n        placeholder={placeholder}\n        type={type}\n        required={required}\n        id={`fresh-${fieldId}-${formId}`}\n        value={data[formId][fieldId]}\n        onChange={e => setField(fieldId, e.target.value, formId)}\n      />\n      {strength && (\n        <div\n          style={{\n            height: '4px',\n            marginBottom: '1rem',\n            transition: '0.3s ease all',\n            ...strengthMeter,\n          }}\n        />\n      )}\n    </>\n  )\n}\n\nconst options = {\n  showText: true,\n  fieldPartialMatch: true,\n  minimumLength: 4,\n}\n\nfunction calculateScore(password: string) {\n  var score = 0\n\n  // password < options.minimumLength\n  if (password.length < options.minimumLength) {\n    return -1\n  }\n  // password length\n  score += password.length * 4\n\n  // password has 3 numbers\n  if (password.match(/(.*[0-9].*[0-9].*[0-9])/)) {\n    score += 5\n  }\n\n  // password has at least 2 sybols\n  var symbols: any = '.*[!,@,#,$,%,^,&,*,?,_,~]'\n  symbols = new RegExp('(' + symbols + symbols + ')')\n  if (password.match(symbols)) {\n    score += 5\n  }\n\n  // password has Upper and Lower chars\n  if (password.match(/([a-z].*[A-Z])|([A-Z].*[a-z])/)) {\n    score += 10\n  }\n\n  // password has number and chars\n  if (password.match(/([a-zA-Z])/) && password.match(/([0-9])/)) {\n    score += 15\n  }\n\n  // password has number and symbol\n  if (\n    password.match(/([!,@,#,$,%,^,&,*,?,_,~])/) &&\n    password.match(/([0-9])/)\n  ) {\n    score += 15\n  }\n\n  // password has char and symbol\n  if (\n    password.match(/([!,@,#,$,%,^,&,*,?,_,~])/) &&\n    password.match(/([a-zA-Z])/)\n  ) {\n    score += 15\n  }\n\n  // password is just numbers or chars\n  if (password.match(/^\\w+$/) || password.match(/^\\d+$/)) {\n    score -= 10\n  }\n\n  if (score > 100) {\n    score = 100\n  }\n\n  if (score < 0) {\n    score = 0\n  }\n\n  return score * 0.04\n}\n\nexport default Password\n","import React, { useEffect } from 'react'\nimport TagsInput from 'react-tagsinput'\nimport { FieldInterface } from './types'\nimport { useForm } from '../state/formState'\n\nconst Tags = ({ fieldId, className = '', formId }: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? []\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <TagsInput\n      value={data[formId][fieldId] || []}\n      onChange={(value: string[]) => setField(fieldId, value, formId)}\n      className={`fresh-input-tags ${className}`}\n      id={`fresh-${fieldId}-${formId}`}\n      style={{\n        marginTop: '1rem',\n      }}\n    />\n  )\n}\n\nexport default Tags\n","import React, { useEffect } from 'react'\nimport { useForm } from '../state/formState'\n\ninterface RefValue {\n  id: string\n  text: string\n}\n\ntype Props = {\n  required?: boolean\n  children: string\n  type?: string\n  fieldId?: string\n  name?: string\n  label?: boolean\n  error?: string\n  placeholder?: string\n  options: any\n  className?: string\n  tooltip?: string\n  strength?: boolean\n  displayProperty?: string\n  formId: string\n}\n\nexport const TextArea: React.FC<Props> = ({\n  className,\n  fieldId,\n  formId,\n  placeholder,\n}) => {\n  const { data, setField, registerField, defaultValues } = useForm()\n\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <textarea\n      id={`fresh-${fieldId}-${formId}`}\n      placeholder={placeholder}\n      value={data[formId][fieldId]}\n      className={`fresh-input fresh-input-textarea ${className}`}\n      onChange={e => setField(fieldId, e.target.value, formId)}\n    />\n  )\n}\n\nexport default TextArea\n","import React, { useEffect } from 'react'\nimport { useForm } from '../state/formState'\nimport { FieldInterface } from './types'\n\nconst NumberField = ({\n  fieldId,\n  placeholder,\n  required,\n  formId,\n  className,\n}: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <input\n      required={required}\n      className={`fresh-input fresh-input-number ${className}`}\n      placeholder={placeholder}\n      id={`fresh-${fieldId}-${formId}`}\n      type=\"number\"\n      value={data[formId][fieldId]}\n      onChange={e => {\n        const value = e.target.value ? parseInt(e.target.value) : null\n        setField(fieldId, value, formId)\n      }}\n    />\n  )\n}\n\nexport default NumberField\n","/* @jsx h */\n/**\n * markdown-to-jsx@6 is a fork of [simple-markdown v0.2.2](https://github.com/Khan/simple-markdown)\n * from Khan Academy. Thank you Khan devs for making such an awesome and extensible\n * parsing infra... without it, half of the optimizations here wouldn't be feasible. 🙏🏼\n */\nimport React from 'react'\nimport unquote from 'unquote'\n\nexport namespace MarkdownToJSX {\n  /**\n   * RequireAtLeastOne<{ ... }> <- only requires at least one key\n   */\n  type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n    T,\n    Exclude<keyof T, Keys>\n  > &\n    {\n      [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n  export type CreateElement = typeof React.createElement\n\n  export type HTMLTags = keyof JSX.IntrinsicElements\n\n  export type State = {\n    _list?: boolean\n    inline?: boolean\n    inTable?: boolean\n    key?: React.Key\n    simple?: boolean\n  }\n\n  export type ParserResult = {\n    [key: string]: any\n    type?: string\n  }\n\n  export type NestedParser = (\n    input: string,\n    state?: MarkdownToJSX.State\n  ) => MarkdownToJSX.ParserResult\n\n  export type Parser<ParserOutput> = (\n    capture: RegExpMatchArray,\n    nestedParse: NestedParser,\n    state?: MarkdownToJSX.State\n  ) => ParserOutput\n\n  export type RuleOutput = (\n    ast: MarkdownToJSX.ParserResult,\n    state: MarkdownToJSX.State\n  ) => JSX.Element\n\n  export type Rule<ParserOutput = MarkdownToJSX.ParserResult> = {\n    match: (\n      source: string,\n      state: MarkdownToJSX.State,\n      prevCapturedString?: string\n    ) => RegExpMatchArray\n    order: Priority\n    parse: MarkdownToJSX.Parser<ParserOutput>\n    react?: (\n      node: ParserOutput,\n      output: RuleOutput,\n      state?: MarkdownToJSX.State\n    ) => React.ReactChild\n  }\n\n  export type Rules = {\n    [key: string]: Rule\n  }\n\n  export type Override =\n    | RequireAtLeastOne<{\n        component: React.ElementType\n        props: Object\n      }>\n    | React.ElementType\n\n  export type Overrides = {\n    [tag in HTMLTags]?: Override\n  } & {\n    [customComponent: string]: Override\n  }\n\n  export type Options = Partial<{\n    /**\n     * Ultimate control over the output of all rendered JSX.\n     */\n    createElement: (\n      tag: Parameters<CreateElement>[0],\n      props: React.Props<any>,\n      ...children: React.ReactChild[]\n    ) => JSX.Element\n\n    /**\n     * Disable the compiler's best-effort transcription of provided raw HTML\n     * into JSX-equivalent. This is the functionality that prevents the need to\n     * use `dangerouslySetInnerHTML` in React.\n     */\n    disableParsingRawHTML: boolean\n\n    /**\n     * Forces the compiler to always output content with a block-level wrapper\n     * (`<p>` or any block-level syntax your markdown already contains.)\n     */\n    forceBlock: boolean\n\n    /**\n     * Forces the compiler to always output content with an inline wrapper (`<span>`)\n     */\n    forceInline: boolean\n\n    /**\n     * Supply additional HTML entity: unicode replacement mappings.\n     *\n     * Pass only the inner part of the entity as the key,\n     * e.g. `&le;` -> `{ \"le\": \"\\u2264\" }`\n     *\n     * By default\n     * the following entites are replaced with their unicode equivalents:\n     *\n     * ```\n     * &amp;\n     * &apos;\n     * &gt;\n     * &lt;\n     * &nbsp;\n     * &quot;\n     * ```\n     */\n    namedCodesToUnicode: {\n      [key: string]: string\n    }\n\n    /**\n     * Selectively control the output of particular HTML tags as they would be\n     * emitted by the compiler.\n     */\n    overrides: Overrides\n\n    /**\n     * Declare the type of the wrapper to be used when there are multiple\n     * children to render. Set to `null` to get an array of children back\n     * without any wrapper, or use `React.Fragment` to get a React element\n     * that won't show up in the DOM.\n     */\n    wrapper: React.ElementType\n\n    /**\n     * Forces the compiler to wrap results, even if there is only a single\n     * child or no children.\n     */\n    forceWrapper: boolean\n\n    /**\n     * Override normalization of non-URI-safe characters for use in generating\n     * HTML IDs for anchor linking purposes.\n     */\n    slugify: (source: string) => string\n  }>\n}\n\n/** TODO: Drop for React 16? */\nconst ATTRIBUTE_TO_JSX_PROP_MAP = {\n  accesskey: 'accessKey',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  autocomplete: 'autoComplete',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  charset: 'charSet',\n  class: 'className',\n  classid: 'classId',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  crossorigin: 'crossOrigin',\n  enctype: 'encType',\n  for: 'htmlFor',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formmethod: 'formMethod',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  hreflang: 'hrefLang',\n  inputmode: 'inputMode',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  marginheight: 'marginHeight',\n  marginwidth: 'marginWidth',\n  maxlength: 'maxLength',\n  mediagroup: 'mediaGroup',\n  minlength: 'minLength',\n  novalidate: 'noValidate',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  spellcheck: 'spellCheck',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  tabindex: 'tabIndex',\n  usemap: 'useMap',\n} as const\n\nconst namedCodesToUnicode = {\n  amp: '\\u0026',\n  apos: '\\u0027',\n  gt: '\\u003e',\n  lt: '\\u003c',\n  nbsp: '\\u00a0',\n  quot: '\\u201c',\n} as const\n\nconst DO_NOT_PROCESS_HTML_ELEMENTS = ['style', 'script']\n\n/**\n * the attribute extractor regex looks for a valid attribute name,\n * followed by an equal sign (whitespace around the equal sign is allowed), followed\n * by one of the following:\n *\n * 1. a single quote-bounded string, e.g. 'foo'\n * 2. a double quote-bounded string, e.g. \"bar\"\n * 3. an interpolation, e.g. {something}\n *\n * JSX can be be interpolated into itself and is passed through the compiler using\n * the same options and setup as the current run.\n *\n * <Something children={<SomeOtherThing />} />\n *                      ==================\n *                              ↳ children: [<SomeOtherThing />]\n *\n * Otherwise, interpolations are handled as strings or simple booleans\n * unless HTML syntax is detected.\n *\n * <Something color={green} disabled={true} />\n *                   =====            ====\n *                     ↓                ↳ disabled: true\n *                     ↳ color: \"green\"\n *\n * Numbers are not parsed at this time due to complexities around int, float,\n * and the upcoming bigint functionality that would make handling it unwieldy.\n * Parse the string in your component as desired.\n *\n * <Something someBigNumber={123456789123456789} />\n *                           ==================\n *                                   ↳ someBigNumber: \"123456789123456789\"\n */\nconst ATTR_EXTRACTOR_R = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi\n\n/** TODO: Write explainers for each of these */\n\nconst AUTOLINK_MAILTO_CHECK_R = /mailto:/i\nconst BLOCK_END_R = /\\n{2,}$/\nconst BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/\nconst BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm\nconst BREAK_LINE_R = /^ {2,}\\n/\nconst BREAK_THEMATIC_R = /^(?:( *[-*_]) *){3,}(?:\\n *)+\\n/\nconst CODE_BLOCK_FENCED_R = /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n?/\nconst CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/\nconst CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/\nconst CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/\nconst CR_NEWLINE_R = /\\r\\n?/g\nconst FOOTNOTE_R = /^\\[\\^([^\\]]+)](:.*)\\n/\nconst FOOTNOTE_REFERENCE_R = /^\\[\\^([^\\]]+)]/\nconst FORMFEED_R = /\\f/g\nconst GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/\nconst HEADING_R = /^ *(#{1,6}) *([^\\n]+)\\n{0,2}/\nconst HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/\n\n/**\n * Explanation:\n *\n * 1. Look for a starting tag, preceeded by any amount of spaces\n *    ^ *<\n *\n * 2. Capture the tag name (capture 1)\n *    ([^ >/]+)\n *\n * 3. Ignore a space after the starting tag and capture the attribute portion of the tag (capture 2)\n *     ?([^>]*)\\/{0}>\n *\n * 4. Ensure a matching closing tag is present in the rest of the input string\n *    (?=[\\s\\S]*<\\/\\1>)\n *\n * 5. Capture everything until the matching closing tag -- this might include additional pairs\n *    of the same tag type found in step 2 (capture 3)\n *    ((?:[\\s\\S]*?(?:<\\1[^>]*>[\\s\\S]*?<\\/\\1>)*[\\s\\S]*?)*?)<\\/\\1>\n *\n * 6. Capture excess newlines afterward\n *    \\n*\n */\nconst HTML_BLOCK_ELEMENT_R = /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i\n\nconst HTML_CHAR_CODE_R = /&([a-z]+);/g\n\nconst HTML_COMMENT_R = /^<!--.*?-->/\n\n/**\n * borrowed from React 15(https://github.com/facebook/react/blob/894d20744cba99383ffd847dbd5b6e0800355a5c/src/renderers/dom/shared/HTMLDOMPropertyConfig.js)\n */\nconst HTML_CUSTOM_ATTR_R = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/\n\nconst HTML_SELF_CLOSING_ELEMENT_R = /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i\nconst INTERPOLATION_R = /^\\{.*\\}$/\nconst LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/\nconst LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/\nconst LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/\nconst LIST_ITEM_END_R = / *\\n+$/\nconst LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/\nconst CAPTURE_LETTER_AFTER_HYPHEN = /-([a-z])?/gi\nconst NP_TABLE_R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/\nconst PARAGRAPH_R = /^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/\nconst REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/\nconst REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst REFERENCE_LINK_R = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst SQUARE_BRACKETS_R = /(\\[|\\])/g\nconst SHOULD_RENDER_AS_BLOCK_R = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/\nconst TAB_R = /\\t/g\nconst TABLE_SEPARATOR_R = /^ *\\| */\nconst TABLE_TRIM_PIPES = /(^ *\\||\\| *$)/g\nconst TABLE_CELL_END_TRIM = / *$/\nconst TABLE_CENTER_ALIGN = /^ *:-+: *$/\nconst TABLE_LEFT_ALIGN = /^ *:-+ *$/\nconst TABLE_RIGHT_ALIGN = /^ *-+: *$/\n\nconst TEXT_BOLD_R = /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/\nconst TEXT_EMPHASIZED_R = /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1)/\nconst TEXT_STRIKETHROUGHED_R = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/\n\nconst TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/\nconst TEXT_PLAIN_R = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i\nconst TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R = /(^\\n+|\\n+$|\\s+$)/g\n\nconst HTML_LEFT_TRIM_AMOUNT_R = /^([ \\t]*)/\n\nconst UNESCAPE_URL_R = /\\\\([^0-9A-Z\\s])/gi\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nconst LIST_BULLET = '(?:[*+-]|\\\\d+\\\\.)'\n\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nconst LIST_ITEM_PREFIX = '( *)(' + LIST_BULLET + ') +'\nconst LIST_ITEM_PREFIX_R = new RegExp('^' + LIST_ITEM_PREFIX)\n\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nconst LIST_ITEM_R = new RegExp(\n  LIST_ITEM_PREFIX +\n    '[^\\\\n]*(?:\\\\n' +\n    '(?!\\\\1' +\n    LIST_BULLET +\n    ' )[^\\\\n]*)*(\\\\n|$)',\n  'gm'\n)\n\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nconst LIST_R = new RegExp(\n  '^( *)(' +\n    LIST_BULLET +\n    ') ' +\n    '[\\\\s\\\\S]+?(?:\\\\n{2,}(?! )' +\n    '(?!\\\\1' +\n    LIST_BULLET +\n    ' (?!' +\n    LIST_BULLET +\n    ' ))\\\\n*' +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    '|\\\\s*\\\\n*$)'\n)\n\nconst LINK_INSIDE = '(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*'\nconst LINK_HREF_AND_TITLE =\n  '\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+[\\'\"]([\\\\s\\\\S]*?)[\\'\"])?\\\\s*'\n\nconst LINK_R = new RegExp(\n  '^\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n)\n\nconst IMAGE_R = new RegExp(\n  '^!\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n)\n\nconst BLOCK_SYNTAXES = [\n  BLOCKQUOTE_R,\n  CODE_BLOCK_R,\n  CODE_BLOCK_FENCED_R,\n  HEADING_R,\n  HEADING_SETEXT_R,\n  HTML_BLOCK_ELEMENT_R,\n  HTML_COMMENT_R,\n  HTML_SELF_CLOSING_ELEMENT_R,\n  LIST_ITEM_R,\n  LIST_R,\n  NP_TABLE_R,\n  PARAGRAPH_R,\n]\n\nfunction containsBlockSyntax(input: string) {\n  return BLOCK_SYNTAXES.some(r => r.test(input))\n}\n\n// based on https://stackoverflow.com/a/18123682/1141611\n// not complete, but probably good enough\nfunction slugify(str: string) {\n  return str\n    .replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, 'a')\n    .replace(/[çÇ]/g, 'c')\n    .replace(/[ðÐ]/g, 'd')\n    .replace(/[ÈÉÊËéèêë]/g, 'e')\n    .replace(/[ÏïÎîÍíÌì]/g, 'i')\n    .replace(/[Ññ]/g, 'n')\n    .replace(/[øØœŒÕõÔôÓóÒò]/g, 'o')\n    .replace(/[ÜüÛûÚúÙù]/g, 'u')\n    .replace(/[ŸÿÝý]/g, 'y')\n    .replace(/[^a-z0-9- ]/gi, '')\n    .replace(/ /gi, '-')\n    .toLowerCase()\n}\n\nfunction parseTableAlignCapture(alignCapture: string) {\n  if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n    return 'right'\n  } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n    return 'center'\n  } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n    return 'left'\n  }\n\n  return null\n}\n\nfunction parseTableRow(\n  source: string,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  const prevInTable = state.inTable\n  state.inTable = true\n  const tableRow = parse(source.trim(), state)\n  state.inTable = prevInTable\n\n  let cells = [[]]\n  tableRow.forEach(function(node, i) {\n    if (node.type === 'tableSeparator') {\n      // Filter out empty table separators at the start/end:\n      if (i !== 0 && i !== tableRow.length - 1) {\n        // Split the current row:\n        cells.push([])\n      }\n    } else {\n      if (\n        node.type === 'text' &&\n        (tableRow[i + 1] == null || tableRow[i + 1].type === 'tableSeparator')\n      ) {\n        node.content = node.content.replace(TABLE_CELL_END_TRIM, '')\n      }\n      cells[cells.length - 1].push(node)\n    }\n  })\n  return cells\n}\n\nfunction parseTableAlign(source: string /*, parse, state*/) {\n  const alignText = source.replace(TABLE_TRIM_PIPES, '').split('|')\n\n  return alignText.map(parseTableAlignCapture)\n}\n\nfunction parseTableCells(\n  source: string,\n  parse: MarkdownToJSX.NestedParser,\n  state: Object\n) {\n  const rowsText = source.trim().split('\\n')\n\n  return rowsText.map(function(rowText) {\n    return parseTableRow(rowText, parse, state)\n  })\n}\n\nfunction parseTable(\n  capture: RegExpMatchArray,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  state.inline = true\n  const header = parseTableRow(capture[1], parse, state)\n  const align = parseTableAlign(capture[2])\n  const cells = parseTableCells(capture[3], parse, state)\n  state.inline = false\n\n  return {\n    align: align,\n    cells: cells,\n    header: header,\n    type: 'table',\n  }\n}\n\nfunction getTableStyle(node, colIndex) {\n  return node.align[colIndex] == null\n    ? {}\n    : {\n        textAlign: node.align[colIndex],\n      }\n}\n\n/** TODO: remove for react 16 */\nfunction normalizeAttributeKey(key) {\n  const hyphenIndex = key.indexOf('-')\n\n  if (hyphenIndex !== -1 && key.match(HTML_CUSTOM_ATTR_R) === null) {\n    key = key.replace(CAPTURE_LETTER_AFTER_HYPHEN, function(_, letter) {\n      return letter.toUpperCase()\n    })\n  }\n\n  return key\n}\n\nfunction attributeValueToJSXPropValue(\n  key: JSX.IntrinsicAttributes,\n  value: string\n): any {\n  if (key === 'style') {\n    return value.split(/;\\s?/).reduce(function(styles, kvPair) {\n      const key = kvPair.slice(0, kvPair.indexOf(':'))\n\n      // snake-case to camelCase\n      // also handles PascalCasing vendor prefixes\n      const camelCasedKey = key.replace(/(-[a-z])/g, substr =>\n        substr[1].toUpperCase()\n      )\n\n      // key.length + 1 to skip over the colon\n      styles[camelCasedKey] = kvPair.slice(key.length + 1).trim()\n\n      return styles\n    }, {})\n  } else if (key === 'href') {\n    return sanitizeUrl(value)\n  } else if (value.match(INTERPOLATION_R)) {\n    // return as a string and let the consumer decide what to do with it\n    value = value.slice(1, value.length - 1)\n  }\n\n  if (value === 'true') {\n    return true\n  } else if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n\nfunction normalizeWhitespace(source: string): string {\n  return source\n    .replace(CR_NEWLINE_R, '\\n')\n    .replace(FORMFEED_R, '')\n    .replace(TAB_R, '    ')\n}\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nfunction parserFor(\n  rules: MarkdownToJSX.Rules\n): (\n  source: string,\n  state: MarkdownToJSX.State\n) => ReturnType<MarkdownToJSX.NestedParser> {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  let ruleList = Object.keys(rules)\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    ruleList.forEach(function(type) {\n      let order = rules[type].order\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        (typeof order !== 'number' || !isFinite(order))\n      ) {\n        console.warn(\n          'markdown-to-jsx: Invalid order for rule `' + type + '`: ' + order\n        )\n      }\n    })\n  }\n\n  ruleList.sort(function(typeA, typeB) {\n    let orderA = rules[typeA].order\n    let orderB = rules[typeB].order\n\n    // First sort based on increasing order\n    if (orderA !== orderB) {\n      return orderA - orderB\n\n      // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1\n    }\n\n    return 1\n  })\n\n  function nestedParse(\n    source: string,\n    state: MarkdownToJSX.State\n  ): MarkdownToJSX.ParserResult[] {\n    let result = []\n\n    // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information).\n    let prevCapture = ''\n    while (source) {\n      let i = 0\n      while (i < ruleList.length) {\n        const ruleType = ruleList[i]\n        const rule = rules[ruleType]\n        const capture = rule.match(source, state, prevCapture)\n\n        if (capture) {\n          const currCaptureString = capture[0]\n          source = source.substring(currCaptureString.length)\n          const parsed = rule.parse(capture, nestedParse, state)\n\n          // We also let rules override the default type of\n          // their parsed node if they would like to, so that\n          // there can be a single output function for all links,\n          // even if there are several rules to parse them.\n          if (parsed.type == null) {\n            parsed.type = ruleType\n          }\n\n          result.push(parsed)\n\n          prevCapture = currCaptureString\n          break\n        }\n\n        i++\n      }\n    }\n\n    return result\n  }\n\n  return function outerParse(source, state) {\n    return nestedParse(normalizeWhitespace(source), state)\n  }\n}\n\n// Creates a match function for an inline scoped or simple element from a regex\nfunction inlineRegex(regex: RegExp) {\n  return function match(source, state) {\n    if (state.inline) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// basically any inline element except links\nfunction simpleInlineRegex(regex: RegExp) {\n  return function match(source: string, state: MarkdownToJSX.State) {\n    if (state.inline || state.simple) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// Creates a match function for a block scoped element from a regex\nfunction blockRegex(regex: RegExp) {\n  return function match(source: string, state: MarkdownToJSX.State) {\n    if (state.inline || state.simple) {\n      return null\n    } else {\n      return regex.exec(source)\n    }\n  }\n}\n\n// Creates a match function from a regex, ignoring block/inline scope\nfunction anyScopeRegex(regex: RegExp) {\n  return function match(source: string /*, state*/) {\n    return regex.exec(source)\n  }\n}\n\nfunction reactFor(outputFunc) {\n  return function nestedReactOutput(\n    ast: MarkdownToJSX.ParserResult | MarkdownToJSX.ParserResult[],\n    state: MarkdownToJSX.State = {}\n  ): React.ReactChild[] {\n    if (Array.isArray(ast)) {\n      const oldKey = state.key\n      const result = []\n\n      // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n      let lastWasString = false\n\n      for (let i = 0; i < ast.length; i++) {\n        state.key = i\n\n        const nodeOut = nestedReactOutput(ast[i], state)\n        const isString = typeof nodeOut === 'string'\n\n        if (isString && lastWasString) {\n          result[result.length - 1] += nodeOut\n        } else {\n          result.push(nodeOut)\n        }\n\n        lastWasString = isString\n      }\n\n      state.key = oldKey\n\n      return result\n    }\n\n    return outputFunc(ast, nestedReactOutput, state)\n  }\n}\n\nfunction sanitizeUrl(url: string): string | null {\n  try {\n    const decoded = decodeURIComponent(url).replace(/[^A-Za-z0-9/:]/g, '')\n\n    if (decoded.match(/^\\s*(javascript|vbscript|data):/i)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'Anchor URL contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n          decoded\n        )\n      }\n\n      return null\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Anchor URL could not be decoded due to malformed syntax or characters, it will not be rendered.',\n        url\n      )\n    }\n\n    // decodeURIComponent sometimes throws a URIError\n    // See `decodeURIComponent('a%AFc');`\n    // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n    return null\n  }\n\n  return url\n}\n\nfunction unescapeUrl(rawUrlString: string): string {\n  return rawUrlString.replace(UNESCAPE_URL_R, '$1')\n}\n\n/**\n * Everything inline, including links.\n */\nfunction parseInline(\n  parse: MarkdownToJSX.NestedParser,\n  content: string,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  const isCurrentlyInline = state.inline || false\n  const isCurrentlySimple = state.simple || false\n  state.inline = true\n  state.simple = true\n  const result = parse(content, state)\n  state.inline = isCurrentlyInline\n  state.simple = isCurrentlySimple\n  return result\n}\n\n/**\n * Anything inline that isn't a link.\n */\nfunction parseSimpleInline(\n  parse: MarkdownToJSX.NestedParser,\n  content: string,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  const isCurrentlyInline = state.inline || false\n  const isCurrentlySimple = state.simple || false\n  state.inline = false\n  state.simple = true\n  const result = parse(content, state)\n  state.inline = isCurrentlyInline\n  state.simple = isCurrentlySimple\n  return result\n}\n\nfunction parseBlock(parse, content, state): MarkdownToJSX.ParserResult {\n  state.inline = false\n  return parse(content + '\\n\\n', state)\n}\n\nconst parseCaptureInline: MarkdownToJSX.Parser<ReturnType<\n  typeof parseInline\n>> = (capture, parse, state) => {\n  return {\n    content: parseInline(parse, capture[1], state),\n  }\n}\n\nfunction captureNothing() {\n  return {}\n}\n\nfunction renderNothing() {\n  return null\n}\n\nfunction ruleOutput(rules: MarkdownToJSX.Rules) {\n  return function nestedRuleOutput(\n    ast: MarkdownToJSX.ParserResult,\n    outputFunc: MarkdownToJSX.RuleOutput,\n    state: MarkdownToJSX.State\n  ): React.ReactChild {\n    return rules[ast.type].react(ast, outputFunc, state)\n  }\n}\n\nfunction cx(...args) {\n  return args.filter(Boolean).join(' ')\n}\n\nfunction get(src: Object, path: string, fb?: any) {\n  let ptr = src\n  const frags = path.split('.')\n\n  while (frags.length) {\n    ptr = ptr[frags[0]]\n\n    if (ptr === undefined) break\n    else frags.shift()\n  }\n\n  return ptr || fb\n}\n\nfunction getTag(tag: string, overrides: MarkdownToJSX.Overrides) {\n  const override = get(overrides, tag)\n\n  if (!override) return tag\n\n  return typeof override === 'function' ||\n    (typeof override === 'object' && 'render' in override)\n    ? override\n    : get(overrides, `${tag}.component`, tag)\n}\n\nenum Priority {\n  /**\n   * anything that must scan the tree before everything else\n   */\n  MAX,\n  /**\n   * scans for block-level constructs\n   */\n  HIGH,\n  /**\n   * inline w/ more priority than other inline\n   */\n  MED,\n  /**\n   * inline elements\n   */\n  LOW,\n  /**\n   * bare text and stuff that is considered leftovers\n   */\n  MIN,\n}\n\nexport function compiler(\n  markdown: string,\n  options: MarkdownToJSX.Options = {}\n) {\n  options.overrides = options.overrides || {}\n  options.slugify = options.slugify || slugify\n  options.namedCodesToUnicode = options.namedCodesToUnicode\n    ? { ...namedCodesToUnicode, ...options.namedCodesToUnicode }\n    : namedCodesToUnicode\n\n  const createElementFn = options.createElement || React.createElement\n\n  // eslint-disable-next-line no-unused-vars\n  function h(\n    // locally we always will render a known string tag\n    tag: MarkdownToJSX.HTMLTags,\n    props: Parameters<MarkdownToJSX.CreateElement>[1] & {\n      className?: string\n    },\n    ...children\n  ) {\n    const overrideProps = get(options.overrides, `${tag}.props`, {})\n\n    return createElementFn(\n      getTag(tag, options.overrides),\n      {\n        ...props,\n        ...overrideProps,\n        className: cx(props?.className, overrideProps.className) || undefined,\n      },\n      ...children\n    )\n  }\n\n  function compile(input: string): JSX.Element {\n    let inline = false\n\n    if (options.forceInline) {\n      inline = true\n    } else if (!options.forceBlock) {\n      /**\n       * should not contain any block-level markdown like newlines, lists, headings,\n       * thematic breaks, blockquotes, tables, etc\n       */\n      inline = SHOULD_RENDER_AS_BLOCK_R.test(input) === false\n    }\n\n    const arr = emitter(\n      parser(\n        inline\n          ? input\n          : `${input.replace(TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R, '')}\\n\\n`,\n        { inline }\n      )\n    )\n\n    if (options.wrapper === null) {\n      return arr\n    }\n\n    const wrapper = options.wrapper || (inline ? 'span' : 'div')\n    let jsx\n\n    if (arr.length > 1 || options.forceWrapper) {\n      jsx = arr\n    } else if (arr.length === 1) {\n      jsx = arr[0]\n\n      // TODO: remove this for React 16\n      if (typeof jsx === 'string') {\n        return <span key=\"outer\">{jsx}</span>\n      } else {\n        return jsx\n      }\n    } else {\n      // TODO: return null for React 16\n      jsx = null\n    }\n\n    return React.createElement(wrapper, { key: 'outer' }, jsx)\n  }\n\n  function attrStringToMap(str: string): React.Props<any> {\n    const attributes = str.match(ATTR_EXTRACTOR_R)\n\n    return attributes\n      ? attributes.reduce(function(map, raw, index) {\n          const delimiterIdx = raw.indexOf('=')\n\n          if (delimiterIdx !== -1) {\n            const key = normalizeAttributeKey(raw.slice(0, delimiterIdx)).trim()\n            const value = unquote(raw.slice(delimiterIdx + 1).trim())\n\n            const mappedKey = ATTRIBUTE_TO_JSX_PROP_MAP[key] || key\n            const normalizedValue = (map[\n              mappedKey\n            ] = attributeValueToJSXPropValue(key, value))\n\n            if (\n              typeof normalizedValue === 'string' &&\n              (HTML_BLOCK_ELEMENT_R.test(normalizedValue) ||\n                HTML_SELF_CLOSING_ELEMENT_R.test(normalizedValue))\n            ) {\n              map[mappedKey] = React.cloneElement(\n                compile(normalizedValue.trim()),\n                { key: index }\n              )\n            }\n          } else if (raw !== 'style') {\n            map[ATTRIBUTE_TO_JSX_PROP_MAP[raw] || raw] = true\n          }\n\n          return map\n        }, {})\n      : undefined\n  }\n\n  function stripHtmlComments(html) {\n    return html.replace(/<!--[\\s\\S]*?(?:-->)/g, '')\n  }\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof markdown !== 'string') {\n      throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`)\n    }\n\n    if (\n      Object.prototype.toString.call(options.overrides) !== '[object Object]'\n    ) {\n      throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`)\n    }\n  }\n\n  const footnotes: { footnote: string; identifier: string }[] = []\n  const refs: { [key: string]: { target: string; title: string } } = {}\n\n  /**\n   * each rule's react() output function goes through our custom h() JSX pragma;\n   * this allows the override functionality to be automatically applied\n   */\n  const rules: MarkdownToJSX.Rules = {\n    blockQuote: {\n      match: blockRegex(BLOCKQUOTE_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        return {\n          content: parse(\n            capture[0].replace(BLOCKQUOTE_TRIM_LEFT_MULTILINE_R, ''),\n            state\n          ),\n        }\n      },\n      react(node, output, state) {\n        return (\n          <blockquote key={state.key}>{output(node.content, state)}</blockquote>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: MarkdownToJSX.ParserResult }>,\n\n    breakLine: {\n      match: anyScopeRegex(BREAK_LINE_R),\n      order: Priority.HIGH,\n      parse: captureNothing,\n      react(_, __, state) {\n        return <br key={state.key} />\n      },\n    },\n\n    breakThematic: {\n      match: blockRegex(BREAK_THEMATIC_R),\n      order: Priority.HIGH,\n      parse: captureNothing,\n      react(_, __, state) {\n        return <hr key={state.key} />\n      },\n    },\n\n    codeBlock: {\n      match: blockRegex(CODE_BLOCK_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[0].replace(/^ {4}/gm, '').replace(/\\n+$/, ''),\n          lang: undefined,\n        }\n      },\n\n      react(node, output, state) {\n        return (\n          <pre key={state.key}>\n            <code className={node.lang ? `lang-${node.lang}` : ''}>\n              {node.content}\n            </code>\n          </pre>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: string; lang?: string }>,\n\n    codeFenced: {\n      match: blockRegex(CODE_BLOCK_FENCED_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[3],\n          lang: capture[2] || undefined,\n          type: 'codeBlock',\n        }\n      },\n    },\n\n    codeInline: {\n      match: simpleInlineRegex(CODE_INLINE_R),\n      order: Priority.LOW,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return <code key={state.key}>{node.content}</code>\n      },\n    } as MarkdownToJSX.Rule<{ content: string }>,\n\n    /**\n     * footnotes are emitted at the end of compilation in a special <footer> block\n     */\n    footnote: {\n      match: blockRegex(FOOTNOTE_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        footnotes.push({\n          footnote: capture[2],\n          identifier: capture[1],\n        })\n\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    footnoteReference: {\n      match: inlineRegex(FOOTNOTE_REFERENCE_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse*/) {\n        return {\n          content: capture[1],\n          target: `#${options.slugify(capture[1])}`,\n        }\n      },\n      react(node, output, state) {\n        return (\n          <a key={state.key} href={sanitizeUrl(node.target)}>\n            <sup key={state.key}>{node.content}</sup>\n          </a>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: string; target: string }>,\n\n    gfmTask: {\n      match: inlineRegex(GFM_TASK_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          completed: capture[1].toLowerCase() === 'x',\n        }\n      },\n      react(node, output, state) {\n        return (\n          <input\n            checked={node.completed}\n            key={state.key}\n            readOnly\n            type=\"checkbox\"\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ completed: boolean }>,\n\n    heading: {\n      match: blockRegex(HEADING_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        return {\n          content: parseInline(parse, capture[2], state),\n          id: options.slugify(capture[2]),\n          level: capture[1].length,\n        }\n      },\n      react(node, output, state) {\n        node.tag = `h${node.level}` as MarkdownToJSX.HTMLTags\n        return (\n          <node.tag id={node.id} key={state.key}>\n            {output(node.content, state)}\n          </node.tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      id: string\n      level: number\n      tag: MarkdownToJSX.HTMLTags\n    }>,\n\n    headingSetext: {\n      match: blockRegex(HEADING_SETEXT_R),\n      order: Priority.MAX,\n      parse(capture, parse, state) {\n        return {\n          content: parseInline(parse, capture[1], state),\n          level: capture[2] === '=' ? 1 : 2,\n          type: 'heading',\n        }\n      },\n    },\n\n    htmlComment: {\n      match: anyScopeRegex(HTML_COMMENT_R),\n      order: Priority.HIGH,\n      parse() {\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    image: {\n      match: simpleInlineRegex(IMAGE_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          alt: capture[1],\n          target: unescapeUrl(capture[2]),\n          title: capture[3],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <img\n            key={state.key}\n            alt={node.alt || undefined}\n            title={node.title || undefined}\n            src={sanitizeUrl(node.target)}\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ alt?: string; target: string; title?: string }>,\n\n    link: {\n      match: inlineRegex(LINK_R),\n      order: Priority.LOW,\n      parse(capture, parse, state) {\n        return {\n          content: parseSimpleInline(parse, capture[1], state),\n          target: unescapeUrl(capture[2]),\n          title: capture[3],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <a key={state.key} href={sanitizeUrl(node.target)} title={node.title}>\n            {output(node.content, state)}\n          </a>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      target: string\n      title?: string\n    }>,\n\n    // https://daringfireball.net/projects/markdown/syntax#autolink\n    linkAngleBraceStyleDetector: {\n      match: inlineRegex(LINK_AUTOLINK_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: [\n            {\n              content: capture[1],\n              type: 'text',\n            },\n          ],\n          target: capture[1],\n          type: 'link',\n        }\n      },\n    },\n\n    linkBareUrlDetector: {\n      match: inlineRegex(LINK_AUTOLINK_BARE_URL_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: [\n            {\n              content: capture[1],\n              type: 'text',\n            },\n          ],\n          target: capture[1],\n          title: undefined,\n          type: 'link',\n        }\n      },\n    },\n\n    linkMailtoDetector: {\n      match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        let address = capture[1]\n        let target = capture[1]\n\n        // Check for a `mailto:` already existing in the link:\n        if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n          target = 'mailto:' + target\n        }\n\n        return {\n          content: [\n            {\n              content: address.replace('mailto:', ''),\n              type: 'text',\n            },\n          ],\n          target: target,\n          type: 'link',\n        }\n      },\n    },\n\n    list: {\n      match(source, state, prevCapture) {\n        // We only want to break into a list if we are at the start of a\n        // line. This is to avoid parsing \"hi * there\" with \"* there\"\n        // becoming a part of a list.\n        // You might wonder, \"but that's inline, so of course it wouldn't\n        // start a list?\". You would be correct! Except that some of our\n        // lists can be inline, because they might be inside another list,\n        // in which case we can parse with inline scope, but need to allow\n        // nested lists inside this inline scope.\n        const isStartOfLine = LIST_LOOKBEHIND_R.exec(prevCapture)\n        const isListBlock = state._list || !state.inline\n\n        if (isStartOfLine && isListBlock) {\n          source = isStartOfLine[1] + source\n\n          return LIST_R.exec(source)\n        } else {\n          return null\n        }\n      },\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        const bullet = capture[2]\n        const ordered = bullet.length > 1\n        const start = ordered ? +bullet : undefined\n        const items = capture[0]\n          // recognize the end of a paragraph block inside a list item:\n          // two or more newlines at end end of the item\n          .replace(BLOCK_END_R, '\\n')\n          .match(LIST_ITEM_R)\n\n        let lastItemWasAParagraph = false\n        const itemContent = items.map(function(item, i) {\n          // We need to see how far indented the item is:\n          const space = LIST_ITEM_PREFIX_R.exec(item)[0].length\n\n          // And then we construct a regex to \"unindent\" the subsequent\n          // lines of the items by that amount:\n          const spaceRegex = new RegExp('^ {1,' + space + '}', 'gm')\n\n          // Before processing the item, we need a couple things\n          const content = item\n            // remove indents on trailing lines:\n            .replace(spaceRegex, '')\n            // remove the bullet:\n            .replace(LIST_ITEM_PREFIX_R, '')\n\n          // Handling \"loose\" lists, like:\n          //\n          //  * this is wrapped in a paragraph\n          //\n          //  * as is this\n          //\n          //  * as is this\n          const isLastItem = i === items.length - 1\n          const containsBlocks = content.indexOf('\\n\\n') !== -1\n\n          // Any element in a list is a block if it contains multiple\n          // newlines. The last element in the list can also be a block\n          // if the previous item in the list was a block (this is\n          // because non-last items in the list can end with \\n\\n, but\n          // the last item can't, so we just \"inherit\" this property\n          // from our previous element).\n          const thisItemIsAParagraph =\n            containsBlocks || (isLastItem && lastItemWasAParagraph)\n          lastItemWasAParagraph = thisItemIsAParagraph\n\n          // backup our state for restoration afterwards. We're going to\n          // want to set state._list to true, and state.inline depending\n          // on our list's looseness.\n          const oldStateInline = state.inline\n          const oldStateList = state._list\n          state._list = true\n\n          // Parse inline if we're in a tight list, or block if we're in\n          // a loose list.\n          let adjustedContent\n          if (thisItemIsAParagraph) {\n            state.inline = false\n            adjustedContent = content.replace(LIST_ITEM_END_R, '\\n\\n')\n          } else {\n            state.inline = true\n            adjustedContent = content.replace(LIST_ITEM_END_R, '')\n          }\n\n          const result = parse(adjustedContent, state)\n\n          // Restore our state before returning\n          state.inline = oldStateInline\n          state._list = oldStateList\n\n          return result\n        })\n\n        return {\n          items: itemContent,\n          ordered: ordered,\n          start: start,\n        }\n      },\n      react(node, output, state) {\n        const Tag = node.ordered ? 'ol' : 'ul'\n\n        return (\n          <Tag key={state.key} start={node.start}>\n            {node.items.map(function generateListItem(item, i) {\n              return <li key={i}>{output(item, state)}</li>\n            })}\n          </Tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      items: MarkdownToJSX.ParserResult[]\n      ordered: boolean\n      start?: number\n    }>,\n\n    newlineCoalescer: {\n      match: blockRegex(CONSECUTIVE_NEWLINE_R),\n      order: Priority.LOW,\n      parse: captureNothing,\n      react(/*node, output, state*/) {\n        return '\\n'\n      },\n    },\n\n    paragraph: {\n      match: blockRegex(PARAGRAPH_R),\n      order: Priority.LOW,\n      parse: parseCaptureInline,\n      react(node, output, state) {\n        return <p key={state.key}>{output(node.content, state)}</p>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n\n    ref: {\n      match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n      order: Priority.MAX,\n      parse(capture /*, parse*/) {\n        refs[capture[1]] = {\n          target: capture[2],\n          title: capture[4],\n        }\n\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    refImage: {\n      match: simpleInlineRegex(REFERENCE_IMAGE_R),\n      order: Priority.MAX,\n      parse(capture) {\n        return {\n          alt: capture[1] || undefined,\n          ref: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <img\n            key={state.key}\n            alt={node.alt}\n            src={sanitizeUrl(refs[node.ref].target)}\n            title={refs[node.ref].title}\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ alt?: string; ref: string }>,\n\n    refLink: {\n      match: inlineRegex(REFERENCE_LINK_R),\n      order: Priority.MAX,\n      parse(capture, parse, state) {\n        return {\n          content: parse(capture[1], state),\n          fallbackContent: parse(\n            capture[0].replace(SQUARE_BRACKETS_R, '\\\\$1'),\n            state\n          ),\n          ref: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return refs[node.ref] ? (\n          <a\n            key={state.key}\n            href={sanitizeUrl(refs[node.ref].target)}\n            title={refs[node.ref].title}\n          >\n            {output(node.content, state)}\n          </a>\n        ) : (\n          <span key={state.key}>{output(node.fallbackContent, state)}</span>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      fallbackContent: MarkdownToJSX.ParserResult\n      ref: string\n    }>,\n\n    table: {\n      match: blockRegex(NP_TABLE_R),\n      order: Priority.HIGH,\n      parse: parseTable,\n      react(node, output, state) {\n        return (\n          <table key={state.key}>\n            <thead>\n              <tr>\n                {node.header.map(function generateHeaderCell(content, i) {\n                  return (\n                    <th key={i} style={getTableStyle(node, i)}>\n                      {output(content, state)}\n                    </th>\n                  )\n                })}\n              </tr>\n            </thead>\n\n            <tbody>\n              {node.cells.map(function generateTableRow(row, i) {\n                return (\n                  <tr key={i}>\n                    {row.map(function generateTableCell(content, c) {\n                      return (\n                        <td key={c} style={getTableStyle(node, c)}>\n                          {output(content, state)}\n                        </td>\n                      )\n                    })}\n                  </tr>\n                )\n              })}\n            </tbody>\n          </table>\n        )\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseTable>>,\n\n    tableSeparator: {\n      match: function(source, state) {\n        if (!state.inTable) {\n          return null\n        }\n        return TABLE_SEPARATOR_R.exec(source)\n      },\n      order: Priority.HIGH,\n      parse: function() {\n        return { type: 'tableSeparator' }\n      },\n      // These shouldn't be reached, but in case they are, be reasonable:\n      react() {\n        return ' | '\n      },\n    },\n\n    text: {\n      // Here we look for anything followed by non-symbols,\n      // double newlines, or double-space-newlines\n      // We break on any symbol characters so that this grammar\n      // is easy to extend without needing to modify this regex\n      match: anyScopeRegex(TEXT_PLAIN_R),\n      order: Priority.MIN,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[0]\n            // nbsp -> unicode equivalent for named chars\n            .replace(HTML_CHAR_CODE_R, (full, inner) => {\n              return options.namedCodesToUnicode[inner]\n                ? options.namedCodesToUnicode[inner]\n                : full\n            }),\n        }\n      },\n      react(node /*, output, state*/) {\n        return node.content\n      },\n    } as MarkdownToJSX.Rule<{ content: string }>,\n\n    textBolded: {\n      match: simpleInlineRegex(TEXT_BOLD_R),\n      order: Priority.MED,\n      parse(capture, parse, state) {\n        return {\n          // capture[1] -> the syntax control character\n          // capture[2] -> inner content\n          content: parse(capture[2], state),\n        }\n      },\n      react(node, output, state) {\n        return <strong key={state.key}>{output(node.content, state)}</strong>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<MarkdownToJSX.NestedParser>>,\n\n    textEmphasized: {\n      match: simpleInlineRegex(TEXT_EMPHASIZED_R),\n      order: Priority.LOW,\n      parse(capture, parse, state) {\n        return {\n          // capture[1] -> opening * or _\n          // capture[2] -> inner content\n          content: parse(capture[2], state),\n        }\n      },\n      react(node, output, state) {\n        return <em key={state.key}>{output(node.content, state)}</em>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<MarkdownToJSX.NestedParser>>,\n\n    textEscaped: {\n      // We don't allow escaping numbers, letters, or spaces here so that\n      // backslashes used in plain text still get rendered. But allowing\n      // escaping anything else provides a very flexible escape mechanism,\n      // regardless of how this grammar is extended.\n      match: simpleInlineRegex(TEXT_ESCAPED_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[1],\n          type: 'text',\n        }\n      },\n    },\n\n    textStrikethroughed: {\n      match: simpleInlineRegex(TEXT_STRIKETHROUGHED_R),\n      order: Priority.LOW,\n      parse: parseCaptureInline,\n      react(node, output, state) {\n        return <del key={state.key}>{output(node.content, state)}</del>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n  }\n\n  // Object.keys(rules).forEach(key => {\n  //     let { match, parse } = rules[key];\n\n  //     rules[key].match = (...args) => {\n  //         const start = performance.now();\n  //         const result = match(...args);\n  //         const delta = performance.now() - start;\n\n  //         if (delta > 5)\n  //             console.warn(\n  //                 `Slow match for ${key}: ${delta.toFixed(3)}ms, input: ${\n  //                     args[0]\n  //                 }`\n  //             );\n\n  //         return result;\n  //     };\n\n  //     rules[key].parse = (...args) => {\n  //         const start = performance.now();\n  //         const result = parse(...args);\n  //         const delta = performance.now() - start;\n\n  //         if (delta > 5)\n  //             console.warn(`Slow parse for ${key}: ${delta.toFixed(3)}ms`);\n\n  //         console.log(`${key}:parse`, `${delta.toFixed(3)}ms`, args[0]);\n\n  //         return result;\n  //     };\n  // });\n\n  if (options.disableParsingRawHTML !== true) {\n    rules.htmlBlock = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        const [, whitespace] = capture[3].match(HTML_LEFT_TRIM_AMOUNT_R)\n        const trimmer = new RegExp(`^${whitespace}`, 'gm')\n        const trimmed = capture[3].replace(trimmer, '')\n\n        const parseFunc = containsBlockSyntax(trimmed)\n          ? parseBlock\n          : parseInline\n\n        const tagName = capture[1].toLowerCase() as MarkdownToJSX.HTMLTags\n        const noInnerParse =\n          DO_NOT_PROCESS_HTML_ELEMENTS.indexOf(tagName) !== -1\n\n        return {\n          attrs: attrStringToMap(capture[2]),\n          /**\n           * if another html block is detected within, parse as block,\n           * otherwise parse as inline to pick up any further markdown\n           */\n          content: noInnerParse ? capture[3] : parseFunc(parse, trimmed, state),\n\n          noInnerParse,\n\n          tag: noInnerParse ? tagName : capture[1],\n        }\n      },\n      react(node, output, state) {\n        return (\n          // @ts-ignore\n          <node.tag key={state.key} {...node.attrs}>\n            {node.noInnerParse\n              ? (node.content as string)\n              : output(node.content as MarkdownToJSX.ParserResult, state)}\n          </node.tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      attrs: ReturnType<typeof attrStringToMap>\n      content: string | ReturnType<MarkdownToJSX.NestedParser>\n      noInnerParse: Boolean\n      tag: string\n    }>\n\n    rules.htmlSelfClosing = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      match: anyScopeRegex(HTML_SELF_CLOSING_ELEMENT_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          attrs: attrStringToMap(capture[2] || ''),\n          tag: capture[1],\n        }\n      },\n      react(node, output, state) {\n        return <node.tag {...node.attrs} key={state.key} />\n      },\n    } as MarkdownToJSX.Rule<{\n      attrs: ReturnType<typeof attrStringToMap>\n      tag: string\n    }>\n  }\n\n  const parser = parserFor(rules)\n  const emitter: Function = reactFor(ruleOutput(rules))\n\n  const jsx = compile(stripHtmlComments(markdown))\n\n  if (footnotes.length) {\n    jsx.props.children.push(\n      <footer key=\"footer\">\n        {footnotes.map(function createFootnote(def) {\n          return (\n            <div id={options.slugify(def.identifier)} key={def.identifier}>\n              {def.identifier}\n              {emitter(parser(def.footnote, { inline: true }))}\n            </div>\n          )\n        })}\n      </footer>\n    )\n  }\n\n  return jsx\n}\n\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n */\nconst Markdown: React.FC<{\n  [key: string]: any\n  children: string\n  options?: MarkdownToJSX.Options\n}> = ({ children, options, ...props }) => {\n  return React.cloneElement(\n    compiler(children, options),\n    props as React.Props<any>\n  )\n}\n\nexport default Markdown\n","import React, { useEffect } from 'react'\nimport Markdown from './MarkdownInput'\nimport { useForm } from '../state/formState'\n\nimport { FieldInterface } from './types'\n\nexport const MarkdownTextArea = ({\n  fieldId,\n  placeholder,\n  formId,\n}: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <div className=\"fresh-markdown-wrapper\">\n      <textarea\n        id={`fresh-${fieldId}`}\n        placeholder={placeholder}\n        value={data[formId][fieldId]}\n        className=\"fresh-input fresh-input-textarea\"\n        onChange={e => setField(fieldId, e.target.value, formId)}\n      />\n      <div className=\"fresh-input fresh-input-markdown\">\n        <Markdown children={data[formId][fieldId] || ''} />\n      </div>\n    </div>\n  )\n}\n\nexport default MarkdownTextArea\n","import React, { useEffect } from 'react'\nimport { FieldInterface } from './types'\nimport { useForm } from '../state/formState'\n\nconst Text = ({\n  className,\n  fieldId,\n  placeholder,\n  required,\n  type,\n  formId,\n}: FieldInterface) => {\n  const { data, setField, registerField, defaultValues } = useForm()\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <input\n      required={required}\n      className={`fresh-input fresh-input-${type} ${className}`}\n      placeholder={placeholder}\n      id={`fresh-${fieldId}-${formId}`}\n      type={type}\n      value={data[formId][fieldId]}\n      onChange={e => setField(fieldId, e.target.value, formId)}\n    />\n  )\n}\n\nexport default Text\n","import React, { useEffect } from 'react'\nimport { FieldInterface } from './types'\nimport { useForm } from '../state/formState'\n\nconst Toggle = ({ fieldId, className = '', formId }: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? false\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <div className={`${className} fresh-switch`}>\n      <input\n        checked={data[formId][fieldId] || false}\n        type=\"checkbox\"\n        id={`fresh-${fieldId}`}\n        className=\"fresh-input-toggle\"\n        onChange={_ => setField(fieldId, !data[formId][fieldId], formId)}\n      />\n      <span\n        className={`fresh-slider ${data[formId][fieldId] ? `on` : ''}`}\n        onChange={_ => setField(fieldId, !data[formId][fieldId], formId)}\n      />\n    </div>\n  )\n}\n\nexport default Toggle\n","import React, { useContext } from 'react'\nimport { FormContext } from './state/formState'\nimport { FieldInterface } from './fields/types'\nimport Tooltip from './form/Tooltip'\nimport Select from './fields/Select'\nimport Reference from './fields/Reference'\nimport Password from './fields/Password'\nimport Tags from './fields/Tags'\nimport TextArea from './fields/TextArea'\nimport NumberField from './fields/Number'\nimport Markdown from './fields/Markdown'\nimport Text from './fields/Text'\nimport Toggle from './fields/Toggle'\n\nconst camelCase = str => {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w|\\s+)/g, function(match, index) {\n    if (+match === 0) return ''\n    return index == 0 ? match.toLowerCase() : match.toUpperCase()\n  })\n}\n\nconst Field = ({\n  required = false,\n  children,\n  name = '',\n  type = 'text',\n  label = true,\n  error,\n  placeholder = '',\n  options,\n  strength,\n  className = '',\n  defaultValue = '',\n  displayProperty = '',\n  valueProperty = '',\n  keyProperty = 'id',\n  tooltip,\n  readOnly = false,\n  wrapperStyle = {},\n}: FieldInterface) => {\n  const fieldId = name || camelCase(children)\n  const { formId } = useContext(FormContext)\n\n  const standardProps = {\n    children,\n    required,\n    name,\n    type,\n    label,\n    error,\n    placeholder,\n    options,\n    className,\n    defaultValue,\n    displayProperty,\n    readOnly,\n    formId,\n  }\n  return (\n    <div className={`fresh-field-wrapper ${fieldId}`} style={wrapperStyle}>\n      <label className=\"fresh-label\" htmlFor={`fresh-${fieldId}`}>\n        <span className=\"fresh-title\">\n          {required && '*'} {label && children}&nbsp;\n          {tooltip && <Tooltip tooltip={tooltip} />}\n        </span>\n        {(() => {\n          switch (type) {\n            case 'select':\n              return (\n                <Select\n                  fieldId={fieldId}\n                  valueProperty={valueProperty}\n                  {...standardProps}\n                />\n              )\n            case 'reference':\n              return (\n                <Reference\n                  fieldId={fieldId}\n                  keyProperty={keyProperty}\n                  {...standardProps}\n                />\n              )\n            case 'password':\n              return (\n                <Password\n                  strength={strength}\n                  fieldId={fieldId}\n                  {...standardProps}\n                />\n              )\n            case 'tags':\n              return <Tags fieldId={fieldId} {...standardProps} />\n            case 'textarea':\n              return <TextArea fieldId={fieldId} {...standardProps} />\n            case 'number':\n              return <NumberField fieldId={fieldId} {...standardProps} />\n            case 'markdown':\n              return <Markdown fieldId={fieldId} {...standardProps} />\n            case 'toggle':\n              return <Toggle fieldId={fieldId} {...standardProps} />\n            default:\n              return <Text fieldId={fieldId} {...standardProps} />\n          }\n        })()}\n      </label>\n      {error && <div className=\"fresh-error\">{error}</div>}\n    </div>\n  )\n}\n\nField.defaultProps = {\n  defaultValue: null,\n  options: [],\n  tooltip: '',\n}\n\nexport default Field\n","import React, { useEffect } from 'react'\nimport { useForm, FormContext } from './state/formState'\nimport CancelButton from './form/CancelButton'\nexport { default as Field } from './Field'\nimport './fields/global.css'\n\ntype FormProps = {\n  cancelAction?: (_: any) => void\n  cancelButton?: boolean\n  cancelText?: string\n  formId: string\n  className?: string\n  defaultValues?: any // sorry. not sure how to type this properly PR wanted\n  onSubmit(formState: { [key: string]: any }): void\n  onChange?(formState: object): void\n  submitText?: string\n}\n\nconst Form: React.FC<FormProps> = ({\n  cancelAction = () => null,\n  onChange = null,\n  cancelButton = true,\n  cancelText = 'Cancel',\n  children,\n  formId,\n  onSubmit,\n  submitText = 'Submit',\n  className = '',\n  defaultValues = {},\n}) => {\n  const { data, register, isReady, unregister } = useForm()\n\n  useEffect(() => {\n    register(defaultValues, formId)\n    return () => {\n      unregister(formId)\n    }\n  }, [])\n\n  if (!isReady[formId]) return null\n\n  return (\n    <FormContext.Provider value={{ formId }}>\n      <form\n        className={`${className} fresh-form`}\n        onSubmit={e => {\n          e.preventDefault()\n          onSubmit(data[formId])\n        }}\n        onChange={() => {\n          if (onChange) onChange(data[formId])\n        }}\n      >\n        {children}\n        <div>\n          <button\n            id=\"fresh-submit\"\n            className=\"fresh-button fresh-submit\"\n            type=\"submit\"\n          >\n            {submitText}\n          </button>\n          {cancelButton && (\n            <CancelButton\n              formId={formId}\n              cancelAction={cancelAction}\n              cancelText={cancelText}\n            />\n          )}\n        </div>\n      </form>\n    </FormContext.Provider>\n  )\n}\n\n// TODO\n// AUto form prop that allows for automatic form building via graphql. Required fields and all\n\n// Future api idea <Form mutation={GRAPHQL_MUTATION} /> one liner\n\n// Reset on submit option\nexport { Form, useForm }\n"]},"metadata":{},"sourceType":"module"}